<!DOCTYPE html>
<html>
<head>
    <title>ZEEWOLF: SAR v7.9.2 - AERO UPDATE</title>
    <style>
        body { background: #000b1a; color: #5f5; font-family: monospace; margin: 0; overflow: hidden; user-select: none; }
        
        /* OVERLAYS */
        #splash, #mission-select, #heli-select, #crash-screen, #win-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 11, 26, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; cursor: default;
        }
        #crash-screen { background: rgba(80, 0, 0, 0.9); display: none; }
        #win-screen { background: rgba(0, 80, 40, 0.9); display: none; }
        
        #mission-select, #heli-select { display: none; }

        /* TEXT */
        .title { font-size: 64px; color: #ff6600; text-shadow: 0 0 20px #ff6600; margin-bottom: 5px; font-weight: bold; }
        .subtitle { font-size: 20px; color: #5f5; margin-bottom: 30px; letter-spacing: 4px; }
        
        /* GRID (2x2) */
        .grid-container {
            display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
            gap: 20px; width: 800px; height: 500px;
        }
        .grid-box {
            background: rgba(0, 40, 15, 0.4); border: 1px solid #3a3; color: #585;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; font-size: 18px; transition: 0.2s; border-radius: 4px; position: relative;
        }
        .grid-box.active {
            border: 2px solid #ff6600; background: rgba(0, 20, 40, 0.6); color: #fff; cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.2);
        }
        
        /* HOVER FIX: Dunkelgrün statt Weiß */
        .grid-box.active:hover {
            background: rgba(0, 60, 30, 0.9); 
            border-color: #5f5;
            color: #fff;
            box-shadow: 0 0 30px #ff6600;
            transform: scale(1.02);
            z-index: 10;
        }
        
        .grid-box.locked { border: 1px dashed #242; color: #242; background: rgba(0,0,0,0.2); }
        .box-label { font-weight: bold; font-size: 20px; margin-top: 10px; text-transform: uppercase;}
        .box-sub { font-size: 14px; margin-top: 5px; opacity: 0.8; }
        
        .mini-canvas { width: 100%; height: 150px; margin-bottom: 5px; pointer-events: none; }
        .start-hint { font-size: 22px; animation: blink 1s infinite; color: #fff; margin-top: 30px; text-transform: uppercase; cursor: pointer; }
        @keyframes blink { 50% { opacity: 0; } }
        #menu-heli-big { width: 800px; height: 300px; margin-bottom: 20px; filter: drop-shadow(0 0 15px rgba(255,102,0,0.3)); }
    </style>
</head>
<body>

    <div id="splash" onclick="toMissionSelect()">
        <div class="title">ZEEWOLF: SAR</div>
        <div class="subtitle">v7.9.2 AERO UPDATE</div>
        <canvas id="menu-heli-big"></canvas>
        <p class="start-hint">CLICK TO START SYSTEM</p>
    </div>

    <div id="mission-select">
        <div class="title">SELECT MISSION</div>
        <div class="subtitle">OPERATION THEATER</div>
        <div class="grid-container">
            <div class="grid-box active" onclick="toHeliSelect()">
                <div class="box-label">COASTAL TRAINING</div>
                <div class="box-sub">Search & Rescue</div>
                <div class="box-sub">Difficulty: Normal</div>
            </div>
            <div class="grid-box locked"><div class="box-label">LOCKED</div><div class="box-sub">Campaign Mode</div></div>
            <div class="grid-box locked"><div class="box-label">LOCKED</div><div class="box-sub">Night Ops</div></div>
            <div class="grid-box locked"><div class="box-label">LOCKED</div><div class="box-sub">Storm Front</div></div>
        </div>
    </div>

    <div id="heli-select">
        <div class="title">HANGAR</div>
        <div class="subtitle">SELECT AIRFRAME</div>
        <div class="grid-container">
            <div class="grid-box active" onclick="startGame('jayhawk')">
                <canvas id="icon-jayhawk" class="mini-canvas" width="300" height="200"></canvas>
                <div class="box-label">MH-60 JAYHAWK</div>
                <div class="box-sub">Classic Heavy Lifter</div>
            </div>
            <div class="grid-box active" onclick="startGame('dolphin')">
                <canvas id="icon-dolphin" class="mini-canvas" width="300" height="200"></canvas>
                <div class="box-label">MH-65 DOLPHIN</div>
                <div class="box-sub">Agile Short Range</div>
            </div>
            <div class="grid-box locked"><div class="box-label">EMPTY SLOT</div><div class="box-sub">No Data</div></div>
            <div class="grid-box locked"><div class="box-label">EMPTY SLOT</div><div class="box-sub">No Data</div></div>
        </div>
    </div>

    <div id="crash-screen" onclick="location.reload()">
        <div class="title" style="color: #fff;">TERMINATED</div>
        <p id="crash-reason" style="color: #f00; font-size: 24px; font-weight: bold;"></p>
        <p class="start-hint">RETRY MISSION</p>
    </div>
    <div id="win-screen" onclick="location.reload()">
        <div class="title" style="color: #fff;">MISSION COMPLETE</div>
        <p style="color: #5f5; font-size: 24px;">ALL PATIENTS RECOVERED</p>
        <p class="start-hint">RETURN TO BASE (CLICK)</p>
    </div>
    <div id="msg" class="msg-popup"></div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const tileW = 64, tileH = 32, stepH = 25, gridSize = 200;
    
    // NAVIGATION
    function toMissionSelect() {
        document.getElementById('splash').style.display = 'none';
        document.getElementById('mission-select').style.display = 'flex';
    }
    
    function toHeliSelect() {
        document.getElementById('mission-select').style.display = 'none';
        document.getElementById('heli-select').style.display = 'flex';
        animateHeliPreviews();
    }

    // GAME VARS
    let gameStarted = false, crashed = false;
    let introActive = false, introProgress = 0;
    let totalRescued = 0, totalSpawned = 0; 
    let points = [], particles = [];
    let cam = { x: 0, y: 0 };
    const PAD = { xMin: 18, xMax: 25, yMin: 17, yMax: 25 };
    const START_POS = { x: 21.5, y: 21.5 };
    const MAX_ALTITUDE = 16.0; 

    // TERRAIN
    for(let x=0; x<=gridSize; x++) {
        points[x] = [];
        for(let y=0; y<=gridSize; y++) {
            let h = Math.sin(x*0.1) * Math.cos(y*0.1) * 3 + Math.cos(x*0.05) * 2;
            if (x >= PAD.xMin && x <= PAD.xMax + 1 && y >= PAD.yMin && y <= PAD.yMax + 1) {
                points[x][y] = 0.5;
            } else {
                points[x][y] = Math.max(-0.2, h);
            }
        }
    }

    let heli = { 
        type: 'jayhawk', 
        x: 0, y: 0, z: 0.5, vx: 0, vy: 0, vz: 0, angle: 0, 
        tilt: 0, roll: 0, winch: 0, fuel: 100, 
        engineOn: false, rotorRPM: 0, rotationPos: 0, onboard: 0
    };
    
    let windAngle = Math.random() * Math.PI * 2;
    let wind = { x: Math.cos(windAngle) * 0.00015, y: Math.sin(windAngle) * 0.00015, phase: 0 }; 
    let casualty = { x: 40, y: 40, rescued: false, hanging: false };
    let keys = {};

    function iso(vx, vy, h, cx, cy, targetCtx = ctx, targetCanvas = canvas, scale = 1) {
        let tW = tileW * scale; let tH = tileH * scale; let sH = stepH * scale;
        return {
            x: (targetCanvas.width / 2) + (vx - vy) * (tW / 2) - cx,
            y: (targetCanvas.height / 2) + (vx + vy) * (tH / 2) - (h * sH) - cy
        };
    }

    function getGround(fx, fy) {
        let x1 = Math.floor(fx), y1 = Math.floor(fy);
        if(x1 < 0 || y1 < 0 || x1 >= gridSize - 1 || y1 >= gridSize - 1) return 0;
        let tX = fx - x1, tY = fy - y1;
        return points[x1][y1]*(1-tX)*(1-tY) + points[x1+1][y1]*tX*(1-tY) + points[x1][y1+1]*(1-tX)*tY + points[x1+1][y1+1]*tX*tY;
    }

    function spawnCasualty() {
        if (totalSpawned < 5) {
            casualty.x = 40 + Math.random() * 100;
            casualty.y = 40 + Math.random() * 100;
            casualty.rescued = false; hanging = false; totalSpawned++;
        } else { casualty.rescued = true; }
    }

    function showMsg(txt) {
        let m = document.getElementById('msg');
        m.innerHTML = txt; m.style.opacity = 1;
        setTimeout(() => { m.style.opacity = 0; }, 2000);
    }

    function drawHangar(camX, cy) {
        const hX = 21; const hY = 17; const hZ = 0.5;
        const hW = 4; const hD = 2.0; const hH = 1.8;
        const bFL = iso(hX, hY + hD, hZ, camX, cy); const bFR = iso(hX + hW, hY + hD, hZ, camX, cy);         
        const bBL = iso(hX, hY, hZ, camX, cy); const bBR = iso(hX + hW, hY, hZ, camX, cy); 
        const tFL = iso(hX, hY + hD, hZ + hH, camX, cy); const tFR = iso(hX + hW, hY + hD, hZ + hH, camX, cy);
        const tBL = iso(hX, hY, hZ + hH, camX, cy); const tBR = iso(hX + hW, hY, hZ + hH, camX, cy);
        ctx.fillStyle = "#bbbbbb"; ctx.beginPath(); ctx.moveTo(bFL.x, bFL.y); ctx.lineTo(bBL.x, bBL.y); ctx.lineTo(tBL.x, tBL.y); ctx.lineTo(tFL.x, tFL.y); ctx.fill(); ctx.strokeStyle = "#999"; ctx.stroke();
        ctx.fillStyle = "#999999"; ctx.beginPath(); ctx.moveTo(bFR.x, bFR.y); ctx.lineTo(bBR.x, bBR.y); ctx.lineTo(tBR.x, tBR.y); ctx.lineTo(tFR.x, tFR.y); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#dddddd"; ctx.beginPath(); ctx.moveTo(tFL.x, tFL.y); ctx.lineTo(tFR.x, tFR.y); ctx.lineTo(tBR.x, tBR.y); ctx.lineTo(tBL.x, tBL.y); ctx.fill(); ctx.strokeStyle = "#fff"; ctx.stroke();
    }

    function drawPadLights(camX, cy) {
        const lights = [{x: PAD.xMin+0.5, y: PAD.yMin+0.5}, {x: PAD.xMax+0.5, y: PAD.yMin+0.5}, {x: PAD.xMax+0.5, y: PAD.yMax+0.5}, {x: PAD.xMin+0.5, y: PAD.yMax+0.5}];
        let blink = Math.floor(Date.now() / 500) % 2 === 0;
        lights.forEach(l => {
            let p = iso(l.x, l.y, 0.5, camX, cy);
            ctx.fillStyle = blink ? "#f00" : "#500"; ctx.beginPath(); ctx.arc(p.x, p.y, blink?3:2.5, 0, 7); ctx.fill();
        });
    }

    function drawWindsock(camX, cy) {
        let wx = PAD.xMin - 1, wy = PAD.yMin + 1; 
        let base = iso(wx, wy, getGround(wx, wy), camX, cy);
        let top = iso(wx, wy, getGround(wx, wy) + 1.2, camX, cy);
        ctx.strokeStyle = "#aaa"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(base.x, base.y); ctx.lineTo(top.x, top.y); ctx.stroke();
        let wIsoX = (Math.cos(windAngle) - Math.sin(windAngle)) * (tileW/2);
        let wIsoY = (Math.cos(windAngle) + Math.sin(windAngle)) * (tileH/2);
        let len = Math.hypot(wIsoX, wIsoY); wIsoX = (wIsoX / len) * 5; wIsoY = (wIsoY / len) * 5;
        let phase = Date.now() * 0.005;
        ctx.fillStyle = "orange"; ctx.beginPath(); ctx.moveTo(top.x, top.y);
        let cx = top.x, cyPos = top.y;
        for(let i=0; i<4; i++) { 
            let bend = Math.sin(phase + i * 0.5) * 1.5; 
            cx += wIsoX; cyPos += wIsoY + bend * 0.3; ctx.lineTo(cx, cyPos); 
        }
        ctx.lineTo(top.x, top.y + 3); ctx.fill();
    }

    // --- HELICOPTER GEOMETRY ---

    function drawHeli(type, hX, hY, hZ, hAngle, hTilt, hRoll, hRotor, camX, camY, targetCtx, targetCanvas, isShadow = false, scaleOverride = 0) {
        const cosA = Math.cos(hAngle), sinA = Math.sin(hAngle);
        
        // SCALE CONFIG: Jayhawk=1.0, Dolphin=0.7 (kleiner)
        let s = (type === 'dolphin') ? 0.7 : 1.0;
        if(scaleOverride > 0) s = scaleOverride * ((type==='dolphin') ? 0.7 : 1.0);

        // Helper to project local coord (lx, ly, lz) to ISO screen
        function p(lx, ly, lz) {
            // Apply Model Scaling here
            lx *= s; ly *= s; lz *= s;
            
            // Rotation/Tilt
            lz += ly * hRoll * 0.5 + lx * hTilt * 0.5;
            
            // World Transform
            let rx = lx * cosA - ly * sinA + hX;
            let ry = lx * sinA + ly * cosA + hY;
            let rz = hZ + lz;
            
            if (isShadow) {
                let g = getGround(rx, ry);
                rz = g > -5 ? g : 0;
            }
            return iso(rx, ry, rz, camX, camY, targetCtx, targetCanvas);
        }

        targetCtx.lineJoin = "round"; targetCtx.lineCap = "round";

        if (type === 'dolphin') {
            // --- DOLPHIN (Smaller, Fenestron) ---
            if(isShadow) {
                targetCtx.fillStyle = `rgba(0,0,0,${Math.max(0, 0.4 - (hZ - getGround(hX, hY))*0.08)})`;
                let sN = p(1.2,0,0); let sT = p(-1.8,0,0); let sL=p(0,0.4,0); let sR=p(0,-0.4,0);
                targetCtx.beginPath(); targetCtx.moveTo(sN.x, sN.y); targetCtx.lineTo(sR.x, sR.y); targetCtx.lineTo(sT.x, sT.y); targetCtx.lineTo(sL.x, sL.y); targetCtx.fill();
                return;
            }

            targetCtx.fillStyle = "#ff6600"; targetCtx.strokeStyle = "#dd3300";
            let nose = p(1.4, 0, 0.2); let tailBase = p(-0.8, 0, 0.5);
            let lSide = p(0, 0.4, 0.4); let rSide = p(0, -0.4, 0.4);

            targetCtx.lineWidth = 1; targetCtx.beginPath();
            targetCtx.moveTo(nose.x, nose.y); targetCtx.lineTo(rSide.x, rSide.y); targetCtx.lineTo(tailBase.x, tailBase.y); targetCtx.lineTo(lSide.x, lSide.y); targetCtx.closePath(); targetCtx.fill();
            
            targetCtx.fillStyle = "#112"; targetCtx.beginPath(); // Windows
            targetCtx.moveTo(p(1.2, 0, 0.25).x, p(1.2, 0, 0.25).y); targetCtx.lineTo(p(0.3, -0.3, 0.6).x, p(0.3, -0.3, 0.6).y); targetCtx.lineTo(p(0.3, 0.3, 0.6).x, p(0.3, 0.3, 0.6).y); targetCtx.fill();

            let tTop = p(-1.8, 0, 1.2); let tBack = p(-2.0, 0, 0.4); // Fenestron
            targetCtx.fillStyle = "#ff6600"; targetCtx.beginPath();
            targetCtx.moveTo(tailBase.x, tailBase.y); targetCtx.lineTo(tTop.x, tTop.y); targetCtx.lineTo(tBack.x, tBack.y); targetCtx.fill();
            targetCtx.fillStyle = "#333"; targetCtx.beginPath(); let fen = p(-1.7, 0, 0.8); targetCtx.arc(fen.x, fen.y, 3 * s, 0, 7); targetCtx.fill();

            targetCtx.strokeStyle = "rgba(220, 245, 255, 0.5)"; targetCtx.lineWidth = 2;
            let hub = p(0, 0, 0.7);
            for(let i=0; i<4; i++) {
                let a = hRotor + i * (Math.PI/2);
                let end = p(Math.cos(a)*2.2, Math.sin(a)*2.2, 0.8);
                targetCtx.beginPath(); targetCtx.moveTo(hub.x, hub.y); targetCtx.lineTo(end.x, end.y); targetCtx.stroke();
            }

        } else {
            // --- JAYHAWK (Original v7.5.1 Logic) ---
            let pN = p(0.8, 0, 0); 
            let pL = p(0, 0.4, 0); 
            let pR = p(0, -0.4, 0); 
            let pB = p(-0.6, 0, 0); 
            let pT = p(-1.8, 0, 0.4); 

            if(isShadow) {
                targetCtx.fillStyle = `rgba(0,0,0,${Math.max(0, 0.4 - (hZ - getGround(hX, hY))*0.08)})`;
                targetCtx.beginPath(); targetCtx.moveTo(pN.x, pN.y); targetCtx.lineTo(pL.x, pL.y); targetCtx.lineTo(pT.x, pT.y); targetCtx.lineTo(pR.x, pR.y); targetCtx.fill();
                return;
            }

            targetCtx.strokeStyle = "#ff6600"; targetCtx.lineWidth = 5 * s;
            targetCtx.beginPath(); targetCtx.moveTo(pB.x, pB.y); targetCtx.lineTo(pT.x, pT.y); targetCtx.stroke();
            
            targetCtx.fillStyle = "#ff6600"; targetCtx.beginPath(); targetCtx.moveTo(pN.x, pN.y); targetCtx.lineTo(pL.x, pL.y); targetCtx.lineTo(pR.x, pR.y); targetCtx.fill();
            
            targetCtx.fillStyle = "#fff"; targetCtx.beginPath(); targetCtx.moveTo(pL.x, pL.y); targetCtx.lineTo(pB.x, pB.y); targetCtx.lineTo(pR.x, pR.y); targetCtx.fill();
            
            targetCtx.strokeStyle = "rgba(220, 245, 255, 0.5)"; targetCtx.lineWidth = 3 * s;
            for(let i=0; i<2; i++) {
                let ang = hRotor + (i * Math.PI);
                let rS = p(-Math.cos(ang), -Math.sin(ang), 0.45);
                let rE = p(Math.cos(ang), Math.sin(ang), 0.45);
                targetCtx.beginPath(); targetCtx.moveTo(rS.x, rS.y); targetCtx.lineTo(rE.x, rE.y); targetCtx.stroke();
            }
        }
    }

    // --- MENUS ---
    function drawBigMenuHeli() {
        if(gameStarted) return;
        const c = document.getElementById('menu-heli-big'); const cx = c.getContext('2d');
        c.width = 800; c.height = 300; cx.clearRect(0,0,c.width,c.height);
        const t = Date.now() * 0.001;
        drawHeli('jayhawk', 0, 0, 0.8, t*0.5, Math.sin(t)*0.1, Math.cos(t)*0.1, t*12, 0, 0, cx, c, false, 3.5);
        if(document.getElementById('splash').style.display !== 'none') requestAnimationFrame(drawBigMenuHeli);
    }
    drawBigMenuHeli();

    function animateHeliPreviews() {
        if(document.getElementById('heli-select').style.display === 'none') return;
        const t = Date.now() * 0.001;
        
        // Jayhawk
        const c1 = document.getElementById('icon-jayhawk');
        if(c1) {
            const cx1 = c1.getContext('2d'); c1.width=300; c1.height=200; cx1.clearRect(0,0,300,200);
            drawHeli('jayhawk', 0, 0, 0, t*0.5, Math.sin(t)*0.1, Math.cos(t)*0.1, t*12, 0, 0, cx1, c1, false, 2.5);
        }
        // Dolphin
        const c2 = document.getElementById('icon-dolphin');
        if(c2) {
            const cx2 = c2.getContext('2d'); c2.width=300; c2.height=200; cx2.clearRect(0,0,300,200);
            drawHeli('dolphin', 0, 0, 0, t*0.5, Math.sin(t)*0.1, Math.cos(t)*0.1, t*12, 0, 0, cx2, c2, false, 2.5);
        }
        requestAnimationFrame(animateHeliPreviews);
    }

    function startGame(type) {
        if(gameStarted) return;
        heli.type = type;
        document.getElementById('heli-select').style.display = 'none';
        
        gameStarted = true; introActive = true; introProgress = 0;
        cam.x = (START_POS.x - START_POS.y) * (tileW / 2); cam.y = (START_POS.x + START_POS.y) * (tileH / 2);
        spawnCasualty(); 
        render();
    }

    window.onkeydown = (e) => keys[e.code] = true;
    window.onkeyup = (e) => keys[e.code] = false;

    function handleParticles() {
        let gH = getGround(heli.x, heli.y);
        if (heli.z < 2.0 && heli.rotorRPM > 0.8 && gH < 0) {
             for(let i=0; i<1; i++) {
                let a = Math.random() * Math.PI * 2;
                particles.push({ x: heli.x + Math.cos(a)*0.6, y: heli.y + Math.sin(a)*0.6, z: 0, vx: Math.cos(a)*0.06, vy: Math.sin(a)*0.06, life: 0.5, color: "200, 230, 255" });
            }
        }
        else if ((heli.z - gH) < 1.2 && heli.rotorRPM > 0.8) {
            for(let i=0; i<1; i++) {
                let a = Math.random() * Math.PI * 2;
                particles.push({ x: heli.x + Math.cos(a)*0.6, y: heli.y + Math.sin(a)*0.6, z: gH, vx: Math.cos(a)*0.04, vy: Math.sin(a)*0.04, life: 0.4, color: "150, 150, 130" });
            }
        }
        particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; });
        particles = particles.filter(p => p.life > 0);
    }

    function update() {
        if(!gameStarted || crashed) return;
        let groundH = getGround(heli.x, heli.y);
        
        // INTRO
        if(introActive) {
            introProgress += 0.005; 
            const startX = 23.0; const startY = 17.5;
            heli.x = startX + (START_POS.x - startX) * introProgress;
            heli.y = startY + (START_POS.y - startY) * introProgress;
            heli.z = 0.5; heli.angle = -Math.PI / 4; heli.rotorRPM = 0; 
            if(introProgress >= 1) {
                introActive = false; heli.engineOn = false; heli.rotorRPM = 0;
                heli.x = START_POS.x; heli.y = START_POS.y;
                showMsg("SYSTEM READY - START ENGINE [W]");
            }
            return;
        }

        // PHYSICS
        let onPad = (heli.x >= PAD.xMin && heli.x <= PAD.xMax && heli.y >= PAD.yMin && heli.y <= PAD.yMax);
        let inAir = heli.z > groundH + 0.15;
        
        handleParticles();
        
        if(!heli.engineOn && onPad && heli.fuel < 100) heli.fuel = Math.min(100, heli.fuel + 0.2);
        wind.phase += 0.01; let gust = 1 + Math.sin(wind.phase) * 0.2;
        if(inAir) { heli.vx += wind.x * gust; heli.vy += wind.y * gust; }

        if (!onPad && heli.z < 0.1) triggerCrash("WATER IMPACT - HULL BREACH");
        if(heli.z < groundH + 0.25) {
            if(!onPad && groundH > 0.1) triggerCrash("ILLEGAL LANDING ZONE"); 
            else if(Math.hypot(heli.vx, heli.vy) > 0.12) triggerCrash("COLLISION SPEED");
            else if(heli.vz < -0.12) triggerCrash("HARD IMPACT");
        }
        
        let nextGround = getGround(heli.x + heli.vx * 5, heli.y + heli.vy * 5);
        if(nextGround > heli.z + 0.2) triggerCrash("TERRAIN COLLISION");
        if(heli.x > 21 && heli.x < 25 && heli.y > 17 && heli.y < 19 && heli.z < 2.3) triggerCrash("STRUCTURAL IMPACT");

        if(heli.x < 1) { heli.x = 1; heli.vx = 0; } if(heli.x > gridSize - 1) { heli.x = gridSize - 1; heli.vx = 0; }
        if(heli.y < 1) { heli.y = 1; heli.vy = 0; } if(heli.y > gridSize - 1) { heli.y = gridSize - 1; heli.vy = 0; }
        if(heli.z > MAX_ALTITUDE) { heli.z = MAX_ALTITUDE; if(heli.vz > 0) heli.vz = 0; }

        heli.rotorRPM = (heli.engineOn && heli.fuel > 0) ? Math.min(1, heli.rotorRPM + 0.005) : Math.max(0, heli.rotorRPM - 0.004);
        heli.rotationPos += heli.rotorRPM * 0.75;
        
        if(keys['KeyW'] && !heli.engineOn && heli.fuel > 0 && onPad) heli.engineOn = true;
        if(keys['KeyS'] && !inAir && heli.engineOn) heli.engineOn = false;

        let liftFactor = (heli.rotorRPM > 0.9) ? 1.0 : 0.0; 
        if(inAir || (heli.engineOn && liftFactor > 0)) {
            // AERO UPDATE: SPEED DEPENDENT STEERING
            let speed = Math.hypot(heli.vx, heli.vy);
            let aeroFactor = Math.max(0.3, 1.0 - (speed * 8.0)); // Harder to turn at speed

            let mod = heli.rotorRPM * (1.0 - (heli.onboard * 0.08));
            if(heli.fuel > 0) {
                if (liftFactor > 0) { 
                    let dX = Math.cos(heli.angle), dY = Math.sin(heli.angle);
                    let sX = Math.cos(heli.angle + Math.PI/2), sY = Math.sin(heli.angle + Math.PI/2);
                    
                    // TILT REVERSED (Corrected Physics)
                    if(keys['ArrowUp']) { 
                        heli.vx += dX*0.0025*mod; heli.vy += dY*0.0025*mod; 
                        heli.tilt = Math.max(heli.tilt-0.02, -0.4); // Nose Down (Negative)
                    }
                    else if(keys['ArrowDown']) { 
                        heli.vx -= dX*0.0015*mod; heli.vy -= dY*0.0015*mod; 
                        heli.tilt = Math.min(heli.tilt+0.02, 0.2); // Nose Up (Positive)
                    }
                    else heli.tilt *= 0.96;

                    if(keys['KeyA']) { heli.vx -= sX*0.001*mod; heli.vy -= sY*0.001*mod; heli.roll = Math.min(heli.roll+0.02, 0.3); }
                    else if(keys['KeyD']) { heli.vx += sX*0.001*mod; heli.vy += sY*0.001*mod; heli.roll = Math.max(heli.roll-0.02, -0.3); }
                    else heli.roll *= 0.96;
                    
                    // YAW AFFECTED BY AERO
                    if(keys['ArrowLeft']) heli.angle -= 0.045 * mod * aeroFactor;
                    if(keys['ArrowRight']) heli.angle += 0.045 * mod * aeroFactor;
                    
                    if(keys['KeyW']) heli.vz += 0.0028 * mod;
                }
                heli.fuel -= 0.012 * mod;
            } else { heli.tilt *= 0.98; heli.roll = Math.sin(Date.now()*0.01)*0.1; heli.vz -= 0.001; }
        }
        if(keys['KeyS'] && inAir) heli.vz -= 0.003; 
        if(heli.fuel <= 0 && inAir) { if(heli.fuel > -1) { showMsg("ENGINE FAILURE: OUT OF FUEL!"); heli.fuel = -1; } heli.engineOn = false; }
        
        heli.vx *= 0.99; heli.vy *= 0.99; heli.vz *= 0.95;
        heli.x += heli.vx; heli.y += heli.vy; heli.z += heli.vz;
        if(heli.z < groundH + 0.1) { heli.z = groundH + 0.1; heli.vz = 0; }

        if(keys['KeyQ']) heli.winch = Math.max(0, heli.winch - 0.02);
        if(keys['KeyE']) heli.winch = Math.min(4.0, heli.winch + 0.02);

        let actualHookZ = Math.max(groundH, heli.z - heli.winch);
        if(!casualty.rescued && !casualty.hanging) {
            let distToCasualty = Math.hypot(heli.x - casualty.x, heli.y - casualty.y);
            if(distToCasualty < 0.8 && Math.abs(actualHookZ - getGround(casualty.x, casualty.y)) < 0.4) {
                casualty.hanging = true; showMsg("PATIENT SECURED!"); heli.winch = Math.max(0, heli.winch - 0.5);
            }
        } else if(casualty.hanging && heli.winch < 0.3) {
            casualty.hanging = false; casualty.rescued = true; heli.onboard++;
            showMsg(`CASUALTY ONBOARD [${heli.onboard}/5]`);
            if (totalRescued + heli.onboard < 5) spawnCasualty(); 
        }

        if(heli.onboard > 0 && !inAir && onPad) {
            totalRescued += heli.onboard; heli.onboard = 0;
            if(totalRescued >= 5) document.getElementById('win-screen').style.display = 'flex';
            else showMsg(`SECURED AT BASE: ${totalRescued}/5`);
        }
    }

    function triggerCrash(reason) {
        crashed = true; document.getElementById('crash-reason').innerHTML = reason;
        document.getElementById('crash-screen').style.display = 'flex';
    }

    function render() {
        if(!gameStarted || crashed) return;
        update();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (!introActive) {
            const targetCamX = (heli.x - heli.y) * (tileW / 2);
            const targetCamY = (heli.x + heli.y) * (tileH / 2);
            cam.x += (targetCamX - cam.x) * 0.1;
            cam.y += (targetCamY - cam.y) * 0.1;
        }

        let renderCX = introActive ? START_POS.x : heli.x;
        let renderCY = introActive ? START_POS.y : heli.y;

        for (let x = Math.floor(renderCX - 12); x < renderCX + 12; x++) {
            for (let y = Math.floor(renderCY - 12); y < renderCY + 12; y++) {
                if(x < 0 || y < 0 || x >= gridSize-1 || y >= gridSize-1) continue;
                const h = [points[x][y], points[x+1][y], points[x+1][y+1], points[x][y+1]];
                const p = [iso(x,y,h[0], cam.x, cam.y), iso(x+1,y,h[1], cam.x, cam.y), iso(x+1,y+1,h[2], cam.x, cam.y), iso(x,y+1,h[3], cam.x, cam.y)];
                let isPad = (x >= PAD.xMin && x <= PAD.xMax && y >= PAD.yMin && y <= PAD.yMax);
                let c = 35 + Math.floor(h[0] * 15);
                ctx.fillStyle = isPad ? "#444" : (h[0] > 0 ? `rgb(${c-10},${c+30},${c-10})` : "#003d7a");
                ctx.beginPath(); ctx.moveTo(p[0].x, p[0].y); ctx.lineTo(p[1].x, p[1].y); ctx.lineTo(p[2].x, p[2].y); ctx.lineTo(p[3].x, p[3].y); ctx.fill();
            }
        }
        
        drawPadLights(cam.x, cam.y);
        drawWindsock(cam.x, cam.y);
        
        particles.forEach(p => {
            let pos = iso(p.x, p.y, p.z, cam.x, cam.y);
            ctx.fillStyle = `rgba(${p.color}, ${p.life})`; ctx.fillRect(pos.x, pos.y, 3, 3);
        });

        function drawHeliWithWinch() {
            drawHeli(heli.type, heli.x, heli.y, heli.z, heli.angle, heli.tilt, heli.roll, heli.rotationPos, cam.x, cam.y, ctx, canvas, true); 
            const wB = iso(heli.x, heli.y, heli.z, cam.x, cam.y);
            const hP = iso(heli.x, heli.y, Math.max(getGround(heli.x, heli.y), heli.z - heli.winch), cam.x, cam.y);
            ctx.strokeStyle = "#bbb"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(wB.x, wB.y); ctx.lineTo(hP.x, hP.y); ctx.stroke();
            if(!casualty.rescued && casualty.hanging) {
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(hP.x, hP.y, 4, 0, 7); ctx.fill();
            }
            drawHeli(heli.type, heli.x, heli.y, heli.z, heli.angle, heli.tilt, heli.roll, heli.rotationPos, cam.x, cam.y, ctx, canvas, false);
        }

        if (introActive) {
            drawHeliWithWinch();
            drawHangar(cam.x, cam.y);
        } else {
            if (heli.y > 19) { 
                drawHangar(cam.x, cam.y);
                drawHeliWithWinch();
            } else {
                drawHeliWithWinch();
                drawHangar(cam.x, cam.y);
            }
        }

        if(!casualty.rescued && !casualty.hanging) {
            let cP = iso(casualty.x, casualty.y, getGround(casualty.x, casualty.y), cam.x, cam.y);
            ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(cP.x, cP.y, 4, 0, 7); ctx.fill();
        }

        if(!introActive) {
            ctx.font = "bold 13px monospace"; ctx.fillStyle = "#5f5";
            let hX = iso(heli.x, heli.y, heli.z, cam.x, cam.y).x + 45, hY = iso(heli.x, heli.y, heli.z, cam.x, cam.y).y - 35;
            ctx.fillText(`ALT: ${Math.round((heli.z-getGround(heli.x, heli.y))*10)}m`, hX, hY);
            ctx.fillText(`SPD: ${Math.round(Math.hypot(heli.vx, heli.vy)*1500)}kmh`, hX, hY + 16);
            ctx.fillStyle = heli.fuel < 20 ? "#f00" : "#5f5";
            ctx.fillText(`FUEL: ${Math.max(0, Math.round(heli.fuel))}%`, hX, hY + 32);
            ctx.fillStyle = "#5f5";
            ctx.fillText(`LOAD: ${heli.onboard}/5`, hX, hY + 48);

            const ms = 140, mp = 20, bx = canvas.width - ms - mp, by = canvas.height - ms - mp;
            const sc = ms / gridSize;
            
            ctx.fillStyle = "rgba(0,30,10,0.85)"; ctx.fillRect(bx, by, ms, ms);
            ctx.strokeStyle = "#5f5"; ctx.strokeRect(bx, by, ms, ms);
            ctx.fillStyle = "#555"; ctx.fillRect(bx + PAD.xMin * sc, by + PAD.yMin * sc, (PAD.xMax - PAD.xMin) * sc, (PAD.yMax - PAD.yMin) * sc);
            ctx.fillStyle = "#fff"; ctx.fillRect(bx + heli.x * sc - 2, by + heli.y * sc - 2, 4, 4);
            if(!casualty.rescued) {
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(bx + casualty.x * sc, by + casualty.y * sc, 3, 0, 7); ctx.fill();
            }
        }
        requestAnimationFrame(render);
    }
    window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
    window.onresize();
</script>
</body>
</html>
