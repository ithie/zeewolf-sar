<!DOCTYPE html>
<html>
<head>
    <title>ZEEWOLF: SAR v15.4 - DYNAMIC BANKING</title>
    <style>
        body { background: #050505; color: #5f5; font-family: monospace; margin: 0; overflow: hidden; user-select: none; }
        
        #splash, #mission-select, #heli-select, #crash-screen, #win-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 5, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; cursor: default;
        }
        #crash-screen { background: rgba(60, 0, 0, 0.9); display: none; }
        #win-screen { background: rgba(0, 60, 30, 0.9); display: none; }
        
        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; opacity: 0; pointer-events: none; z-index: 150; mix-blend-mode: overlay; transition: opacity 0.1s;
        }

        #mission-select, #heli-select { display: none; }

        .title { font-size: 64px; color: #ff6600; text-shadow: 0 0 20px #ff6600; margin-bottom: 5px; font-weight: bold; }
        .subtitle { font-size: 20px; color: #5f5; margin-bottom: 30px; letter-spacing: 4px; }
        
        .grid-container, .mission-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; width: 900px; height: 350px; }
        
        .grid-box {
            background: rgba(0, 40, 15, 0.4); border: 1px solid #3a3; color: #585;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; font-size: 16px; transition: 0.2s; border-radius: 4px; cursor: pointer;
        }
        .grid-box:hover {
            background: rgba(0, 60, 30, 0.9); border-color: #5f5; color: #fff;
            box-shadow: 0 0 30px #ff6600; transform: scale(1.02); z-index: 10;
        }
        .grid-box.locked { border: 1px dashed #242; color: #242; background: rgba(0,0,0,0.2); pointer-events: none; }
        
        .box-label { font-weight: bold; font-size: 18px; margin-top: 10px; text-transform: uppercase;}
        .box-sub { font-size: 13px; margin-top: 5px; opacity: 0.8; }
        .mini-canvas { width: 100%; height: 120px; margin-bottom: 5px; pointer-events: none; }
        .start-hint { font-size: 22px; animation: blink 1s infinite; color: #fff; margin-top: 30px; cursor: pointer; }
        @keyframes blink { 50% { opacity: 0; } }
        #menu-heli-big { width: 800px; height: 300px; margin-bottom: 20px; filter: drop-shadow(0 0 15px rgba(255,102,0,0.3)); }
        #msg { position:absolute; top:20%; width:100%; text-align:center; font-size:24px; color:#fff; text-shadow:0 0 5px #000; pointer-events:none; opacity:0; transition:opacity 0.5s; z-index: 300; }
    </style>
</head>
<body>

    <div id="flash-overlay"></div>
    <div id="msg"></div>

    <div id="splash" onclick="toMissionSelect()">
        <div class="title">ZEEWOLF: SAR</div>
        <div class="subtitle">v15.4 DYNAMIC BANKING</div>
        <canvas id="menu-heli-big"></canvas>
        <p class="start-hint">CLICK TO START SYSTEM</p>
    </div>

    <div id="mission-select">
        <div class="title">SELECT MISSION</div>
        <div class="subtitle">OPERATION THEATER</div>
        <div class="mission-grid">
            <div class="grid-box" onclick="selectMission('coastal')"><div class="box-label">COASTAL TRAINING</div><div class="box-sub">Sunny / Standard</div><div class="box-sub">Goal: 10 Survivors</div></div>
            <div class="grid-box" onclick="selectMission('recovery')"><div class="box-label">RECOVERY OP</div><div class="box-sub" style="color:#fb0">HEAVY CRATES (Pendulum)</div><div class="box-sub">Goal: 3 Crates</div></div>
            <div class="grid-box" onclick="selectMission('storm')"><div class="box-label">THE STORM</div><div class="box-sub" style="color:#0cf">RAIN / WIND / SEA</div><div class="box-sub">Goal: 8 Survivors</div></div>
        </div>
    </div>

    <div id="heli-select">
        <div class="title">HANGAR</div>
        <div class="subtitle">SELECT AIRFRAME</div>
        <div class="grid-container">
            <div class="grid-box" onclick="startGame('classic')"><canvas id="icon-classic" class="mini-canvas" width="300" height="200"></canvas><div class="box-label">CLASSIC (TYPE-Z)</div><div class="box-sub">Balanced</div><div class="box-sub" style="color:#aaa">Cap: 5</div></div>
            <div class="grid-box" onclick="startGame('dolphin')"><canvas id="icon-dolphin" class="mini-canvas" width="300" height="200"></canvas><div class="box-label">MH-65 DOLPHIN</div><div class="box-sub">Agile / Fast</div><div class="box-sub" style="color:#aaa">Cap: 3 (Lightweight)</div></div>
            <div class="grid-box" onclick="startGame('jayhawk')"><canvas id="icon-jayhawk" class="mini-canvas" width="300" height="200"></canvas><div class="box-label">MH-60T JAYHAWK</div><div class="box-sub">Heavy / Stable</div><div class="box-sub" style="color:#aaa">Cap: 10 (Heavy Lift)</div></div>
        </div>
    </div>

    <div id="crash-screen" onclick="location.reload()"><div class="title" style="color:#fff">TERMINATED</div><p id="crash-reason" style="color:#f00;font-size:24px;font-weight:bold"></p><p class="start-hint">RETRY</p></div>
    <div id="win-screen" onclick="location.reload()"><div class="title" style="color:#fff">MISSION COMPLETE</div><p style="color:#5f5;font-size:24px">ALL OBJECTIVES CLEARED</p><p class="start-hint">RETURN TO BASE</p></div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const tileW = 64, tileH = 32, stepH = 25, gridSize = 200;
    
    // STATE
    let gameStarted = false, crashed = false;
    let introActive = false, introProgress = 0;
    let missionType = 'coastal'; 
    let goalCount = 10, totalRescued = 0, totalSpawned = 0; 
    let stormActive = false;

    let points = [], particles = [];
    let cam = { x: 0, y: 0 };
    const PAD = { xMin: 18, xMax: 25, yMin: 17, yMax: 25 };
    const START_POS = { x: 21.5, y: 21.5 };
    
    for(let x=0; x<=gridSize; x++) { points[x] = []; for(let y=0; y<=gridSize; y++) { points[x][y] = 0; } }

    let heli = { 
        type: 'classic', x: 0, y: 0, z: 0.5, vx: 0, vy: 0, vz: 0, angle: 0, 
        tilt: 0, roll: 0, winch: 0, fuel: 100, engineOn: false, rotorRPM: 0, rotationPos: 0, onboard: 0,
        maxLoad: 5, accel: 0.0025, friction: 0.99, tiltSpeed: 0.02, fuelRate: 0.012, liftPower: 0.003, inAir: false,
        cargoResist: 1.0 
    };
    
    let payload = { x: 40, y: 40, z: 0, vx: 0, vy: 0, rescued: false, hanging: false, type: 'person' };
    let windAngle = Math.random() * Math.PI * 2;
    let wind = { x: 0, y: 0, phase: 0 }; 
    let keys = {};

    function toMissionSelect() { document.getElementById('splash').style.display='none'; document.getElementById('mission-select').style.display='flex'; }
    
    function selectMission(type) {
        missionType = type;
        if(type === 'coastal') { goalCount = 10; stormActive = false; }
        if(type === 'recovery') { goalCount = 3; stormActive = false; }
        if(type === 'storm') { goalCount = 8; stormActive = true; }
        document.getElementById('mission-select').style.display='none';
        document.getElementById('heli-select').style.display='flex';
        animateHeliPreviews();
    }

    function generateTerrain() {
        for(let x=0; x<=gridSize; x++) {
            for(let y=0; y<=gridSize; y++) {
                if (x >= PAD.xMin && x <= PAD.xMax + 1 && y >= PAD.yMin && y <= PAD.yMax + 1) {
                    points[x][y] = 0.5;
                } else {
                    if (missionType === 'storm') {
                        let island = Math.sin(x*0.05) * Math.cos(y*0.05) * 4 - 3.5;
                        points[x][y] = Math.max(-0.5, island);
                    } else if (missionType === 'recovery') {
                        let h = Math.sin(x*0.15) * Math.cos(y*0.15) * 4;
                        points[x][y] = Math.max(-0.2, h);
                    } else {
                        let h = Math.sin(x*0.1) * Math.cos(y*0.1) * 3 + Math.cos(x*0.05) * 2;
                        points[x][y] = Math.max(-0.2, h);
                    }
                }
            }
        }
    }

    function iso(vx, vy, h, cx, cy, canvasRef) {
        let cv = canvasRef || canvas;
        return {
            x: (cv.width / 2) + (vx - vy) * (tileW / 2) - cx,
            y: (cv.height / 2) + (vx + vy) * (tileH / 2) - (h * stepH) - cy
        };
    }

    function getGround(fx, fy) {
        let x1 = Math.floor(fx), y1 = Math.floor(fy);
        if(x1 < 0 || y1 < 0 || x1 >= gridSize - 1 || y1 >= gridSize - 1) return -0.5;
        let tX = fx - x1, tY = fy - y1;
        return points[x1][y1]*(1-tX)*(1-tY) + points[x1+1][y1]*tX*(1-tY) + points[x1][y1+1]*(1-tX)*tY + points[x1+1][y1+1]*tX*tY;
    }

    function spawnPayload() {
        if (totalRescued + heli.onboard < goalCount && !payload.hanging && payload.rescued) {
            let valid = false, attempts = 0;
            while(!valid && attempts < 200) {
                attempts++;
                payload.x = 5 + Math.random() * (gridSize - 10);
                payload.y = 5 + Math.random() * (gridSize - 10);
                let g = getGround(payload.x, payload.y);
                if (missionType === 'storm') { if (g < 0) valid = true; }
                else { if (g > 0 && (payload.x < PAD.xMin || payload.x > PAD.xMax)) valid = true; }
            }
            if(!valid) { payload.x = 30; payload.y = 30; } 
            payload.z = getGround(payload.x, payload.y);
            payload.vx = 0; payload.vy = 0; 
            payload.rescued = false; payload.hanging = false;
            payload.type = (missionType === 'recovery') ? 'crate' : 'person';
            totalSpawned++;
        }
    }

    function showMsg(txt) {
        let m = document.getElementById('msg'); m.innerHTML = txt; m.style.opacity = 1;
        setTimeout(() => { m.style.opacity = 0; }, 2000);
    }

    function handleParticles() {
        let gH = getGround(heli.x, heli.y);
        // Land Dust
        if (heli.z < 2.5 && heli.rotorRPM > 0.8 && gH > 0) { 
            for(let i=0; i<1; i++) { 
                let a = Math.random() * Math.PI * 2; 
                particles.push({ x: heli.x + Math.cos(a)*0.6, y: heli.y + Math.sin(a)*0.6, z: gH + 0.1, vx: Math.cos(a)*0.06, vy: Math.sin(a)*0.06, life: 0.5, color: "150, 140, 120" }); 
            } 
        }
        // Water Spray
        else if (heli.z < 2.0 && heli.rotorRPM > 0.8 && gH < 0) { 
            for(let i=0; i<2; i++) { 
                let a = Math.random() * Math.PI * 2; 
                particles.push({ x: heli.x + Math.cos(a)*0.6, y: heli.y + Math.sin(a)*0.6, z: 0, vx: Math.cos(a)*0.08, vy: Math.sin(a)*0.08, life: 0.4, color: "200, 230, 255" }); 
            } 
        }
        particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; }); 
        particles = particles.filter(p => p.life > 0);
    }

    function updatePhysics() {
        let baseWind = stormActive ? 0.0004 : 0.00015;
        wind.phase += 0.01;
        let gust = 1 + Math.sin(wind.phase) * (stormActive ? 0.8 : 0.2);
        wind.x = Math.cos(windAngle) * baseWind * gust;
        wind.y = Math.sin(windAngle) * baseWind * gust;

        let groundH = getGround(heli.x, heli.y);
        let onPad = (heli.x >= PAD.xMin && heli.x <= PAD.xMax && heli.y >= PAD.yMin && heli.y <= PAD.yMax);

        if(keys['KeyW'] && !heli.engineOn && heli.fuel > 0 && onPad) heli.engineOn = true;
        if(keys['KeyS'] && !heli.inAir && heli.engineOn && heli.rotorRPM < 0.1) heli.engineOn = false;
        heli.rotorRPM = (heli.engineOn && heli.fuel > 0) ? Math.min(1, heli.rotorRPM + 0.005) : Math.max(0, heli.rotorRPM - 0.004);
        heli.rotationPos += heli.rotorRPM * 0.75;

        handleParticles();

        if (payload.hanging) {
            let hookZ = heli.z - heli.winch;
            let tension = 0.005; let damping = 0.98;
            let ax = (heli.x - payload.x) * tension + (wind.x * 2.0);
            let ay = (heli.y - payload.y) * tension + (wind.y * 2.0);
            payload.vx += ax; payload.vy += ay;
            payload.x += payload.vx; payload.y += payload.vy; payload.z = hookZ;
            payload.vx *= damping; payload.vy *= damping;
            
            let baseMass = (payload.type === 'crate') ? 0.8 : 0.2;
            let finalImpact = baseMass * heli.cargoResist; 
            heli.vx -= ax * finalImpact; 
            heli.vy -= ay * finalImpact;

        } else if (!payload.rescued) {
            if (getGround(payload.x, payload.y) < 0) payload.z = -0.3 + Math.sin(Date.now()*0.002)*0.1;
        }

        let lift = (heli.rotorRPM > 0.9) ? 1.0 : 0.0;
        let inAir = heli.z > groundH + 0.15;
        heli.inAir = inAir;

        if(inAir || (heli.engineOn && lift > 0)) {
            let spd = Math.hypot(heli.vx, heli.vy);
            let aero = Math.max(0.3, 1.0 - (spd * 8.0));
            let mod = heli.rotorRPM * (1.0 - (heli.onboard * 0.03)); 

            if(heli.fuel > 0 && lift > 0) {
                let dX = Math.cos(heli.angle), dY = Math.sin(heli.angle);
                let sX = Math.cos(heli.angle + Math.PI/2), sY = Math.sin(heli.angle + Math.PI/2);
                
                // PITCH & SPEED
                if(keys['ArrowUp']) { heli.vx += dX * heli.accel * mod; heli.vy += dY * heli.accel * mod; heli.tilt = Math.max(heli.tilt - heli.tiltSpeed, -0.4); }
                else if(keys['ArrowDown']) { heli.vx -= dX * heli.accel * mod; heli.vy -= dY * heli.accel * mod; heli.tilt = Math.min(heli.tilt + heli.tiltSpeed, 0.2); }
                else heli.tilt *= 0.96;

                // --- NEW: DYNAMIC BANKING LOGIC ---
                let turning = false;

                // Strafing (Strong Roll)
                if(keys['KeyA']) { 
                    heli.vx -= sX*0.001*mod; heli.vy -= sY*0.001*mod; 
                    heli.roll = Math.min(heli.roll+0.02, 0.4); 
                    turning = true; 
                }
                else if(keys['KeyD']) { 
                    heli.vx += sX*0.001*mod; heli.vy += sY*0.001*mod; 
                    heli.roll = Math.max(heli.roll-0.02, -0.4); 
                    turning = true; 
                }

                // Turning (Subtle Bank Roll)
                if(keys['ArrowLeft']) { 
                    heli.angle -= 0.045 * mod * aero; 
                    heli.roll = Math.min(heli.roll + 0.012, 0.4); // Lean into turn
                    turning = true;
                }
                if(keys['ArrowRight']) { 
                    heli.angle += 0.045 * mod * aero; 
                    heli.roll = Math.max(heli.roll - 0.012, -0.4); // Lean into turn
                    turning = true;
                }

                if(!turning) heli.roll *= 0.96;
                // ----------------------------------
                
                if(keys['KeyW']) heli.vz += heli.liftPower * mod;
                else if(keys['KeyS']) heli.vz -= 0.002;
                else heli.vz *= 0.9;
                
                heli.fuel -= heli.fuelRate * mod;
            } else { heli.tilt *= 0.98; heli.roll = Math.sin(Date.now()*0.01)*0.1; }
            if(stormActive) { heli.vx += wind.x * 0.1; heli.vy += wind.y * 0.1; }
        }
        
        if(heli.fuel <= 0 && inAir) { if(heli.fuel > -1) { showMsg("OUT OF FUEL!"); heli.fuel = -1; } heli.engineOn = false; heli.vz -= 0.002; }
        heli.vx *= heli.friction; heli.vy *= heli.friction; 
        heli.x += heli.vx; heli.y += heli.vy; heli.z += heli.vz;
        
        // BOUNDARIES
        const margin = 2;
        if(heli.x < margin) { heli.x = margin; heli.vx = 0; }
        if(heli.x > gridSize - margin) { heli.x = gridSize - margin; heli.vx = 0; }
        if(heli.y < margin) { heli.y = margin; heli.vy = 0; }
        if(heli.y > gridSize - margin) { heli.y = gridSize - margin; heli.vy = 0; }

        // ALTITUDE CEILING
        if(heli.z > 20.0) { 
            heli.z = 20.0; heli.vz = 0; 
            if(Math.random() < 0.05) showMsg("MAX ALTITUDE");
        }
        if(heli.z < groundH + 0.1) { heli.z = groundH + 0.1; heli.vz = 0; }

        if(keys['KeyQ']) heli.winch = Math.max(0, heli.winch - 0.02);
        if(keys['KeyE']) heli.winch = Math.min(5.0, heli.winch + 0.02);

        if(!payload.rescued && !payload.hanging) {
            let dist = Math.hypot(heli.x - payload.x, heli.y - payload.y);
            let hZ = heli.z - heli.winch;
            if(dist < 1.5 && Math.abs(hZ - getGround(payload.x, payload.y)) < 0.8) {
                payload.hanging = true; showMsg(payload.type === 'crate' ? "CARGO SECURED!" : "PATIENT SECURED!");
                heli.winch = Math.max(0, heli.winch - 0.5);
            }
        } else if (payload.hanging && heli.winch < 0.5) {
            if (payload.type === 'person') {
                if (heli.onboard < heli.maxLoad) {
                    payload.hanging = false; payload.rescued = true; heli.onboard++;
                    showMsg(`ONBOARD [${heli.onboard}/${heli.maxLoad}]`);
                    if(totalRescued + heli.onboard < goalCount) spawnPayload();
                } else showMsg("CABIN FULL!");
            } else {
                if (onPad && heli.z < 3.0) {
                    payload.hanging = false; payload.rescued = true; totalRescued++;
                    showMsg("DELIVERED!");
                    if(totalRescued < goalCount) spawnPayload();
                    else document.getElementById('win-screen').style.display = 'flex';
                } else { showMsg("DROP AT PAD!"); heli.winch = 0.6; }
            }
        }
        
        // REFUELING & UNLOADING
        if(!inAir && onPad) {
            if(heli.fuel < 100) heli.fuel = Math.min(100, heli.fuel + 0.5); // Refuel speed
            if(heli.onboard > 0) {
                totalRescued += heli.onboard; heli.onboard = 0;
                if(totalRescued >= goalCount) document.getElementById('win-screen').style.display = 'flex';
                else { showMsg(`SECURED: ${totalRescued}/${goalCount}`); spawnPayload(); }
            }
        }
        
        if (!introActive) {
            if (!onPad && heli.z < 0.1 && getGround(heli.x, heli.y) < 0) triggerCrash("WATER IMPACT");
            if(heli.z < groundH + 0.25) { 
                if(!onPad && groundH > 0.1) triggerCrash("BAD LANDING ZONE"); 
                else if(Math.hypot(heli.vx, heli.vy) > 0.12) triggerCrash("TOO FAST"); 
                else if(heli.vz < -0.15) triggerCrash("HARD IMPACT"); 
            }
        }
    }

    function triggerCrash(reason) {
        crashed = true; document.getElementById('crash-reason').innerHTML = reason;
        document.getElementById('crash-screen').style.display = 'flex';
    }

    function drawHangar(cx, cy) {
        const hX = 21; const hY = 17; const hZ = 0.5;
        const bFL = iso(hX, hY + 2.0, hZ, cx, cy); const bFR = iso(hX + 4, hY + 2.0, hZ, cx, cy);         
        const bBL = iso(hX, hY, hZ, cx, cy); const bBR = iso(hX + 4, hY, hZ, cx, cy); 
        const tFL = iso(hX, hY + 2.0, hZ + 1.8, cx, cy); const tFR = iso(hX + 4, hY + 2.0, hZ + 1.8, cx, cy);
        const tBL = iso(hX, hY, hZ + 1.8, cx, cy); const tBR = iso(hX + 4, hY, hZ + 1.8, cx, cy);
        ctx.fillStyle = "#bbbbbb"; ctx.beginPath(); ctx.moveTo(bFL.x, bFL.y); ctx.lineTo(bBL.x, bBL.y); ctx.lineTo(tBL.x, tBL.y); ctx.lineTo(tFL.x, tFL.y); ctx.fill(); ctx.strokeStyle = "#999"; ctx.stroke();
        ctx.fillStyle = "#999999"; ctx.beginPath(); ctx.moveTo(bFR.x, bFR.y); ctx.lineTo(bBR.x, bBR.y); ctx.lineTo(tBR.x, tBR.y); ctx.lineTo(tFR.x, tFR.y); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#dddddd"; ctx.beginPath(); ctx.moveTo(tFL.x, tFL.y); ctx.lineTo(tFR.x, tFR.y); ctx.lineTo(tBR.x, tBR.y); ctx.lineTo(tBL.x, tBL.y); ctx.fill(); ctx.strokeStyle = "#fff"; ctx.stroke();
    }

    function drawHeli(type, hX, hY, hZ, hAngle, hTilt, hRoll, hRotor, camX, camY, targetCtx, targetCanvas, isShadow = false, scaleOverride = 0) {
        const cosA = Math.cos(hAngle), sinA = Math.sin(hAngle);
        let s = (type === 'dolphin') ? 0.7 : 1.0;
        if(scaleOverride > 0) s = scaleOverride * ((type==='dolphin') ? 0.7 : 1.0);

        function p(lx, ly, lz) {
            lx *= s; ly *= s; lz *= s;
            lz += ly * hRoll * 0.5 + lx * hTilt * 0.5;
            let rx = lx * cosA - ly * sinA + hX;
            let ry = lx * sinA + ly * cosA + hY;
            let rz = hZ + lz;
            if (isShadow) { let g = getGround(rx, ry); rz = g > -5 ? g : 0; }
            return iso(rx, ry, rz, camX, camY, targetCanvas);
        }

        targetCtx.lineJoin = "round"; targetCtx.lineCap = "round";

        if (type === 'dolphin') {
            if(isShadow) {
                targetCtx.fillStyle = `rgba(0,0,0,${Math.max(0, 0.4 - (hZ - getGround(hX, hY))*0.08)})`;
                let sN = p(1.2,0,0); let sT = p(-1.8,0,0); let sL=p(0,0.4,0); let sR=p(0,-0.4,0);
                targetCtx.beginPath(); targetCtx.moveTo(sN.x, sN.y); targetCtx.lineTo(sR.x, sR.y); targetCtx.lineTo(sT.x, sT.y); targetCtx.lineTo(sL.x, sL.y); targetCtx.fill();
                return;
            }
            targetCtx.fillStyle = "#ff6600"; targetCtx.strokeStyle = "#dd3300"; targetCtx.lineWidth = 1;
            let nose = p(1.4, 0, 0.2); let tailBase = p(-0.8, 0, 0.5); let lSide = p(0, 0.4, 0.4); let rSide = p(0, -0.4, 0.4);
            targetCtx.beginPath(); targetCtx.moveTo(nose.x, nose.y); targetCtx.lineTo(rSide.x, rSide.y); targetCtx.lineTo(tailBase.x, tailBase.y); targetCtx.lineTo(lSide.x, lSide.y); targetCtx.closePath(); targetCtx.fill();
            targetCtx.fillStyle = "#112"; targetCtx.beginPath(); targetCtx.moveTo(p(1.2, 0, 0.25).x, p(1.2, 0, 0.25).y); targetCtx.lineTo(p(0.3, -0.3, 0.6).x, p(0.3, -0.3, 0.6).y); targetCtx.lineTo(p(0.3, 0.3, 0.6).x, p(0.3, 0.3, 0.6).y); targetCtx.fill();
            let tTop = p(-1.8, 0, 1.2); let tBack = p(-2.0, 0, 0.4); 
            targetCtx.fillStyle = "#ff6600"; targetCtx.beginPath(); targetCtx.moveTo(tailBase.x, tailBase.y); targetCtx.lineTo(tTop.x, tTop.y); targetCtx.lineTo(tBack.x, tBack.y); targetCtx.fill();
            targetCtx.fillStyle = "#333"; targetCtx.beginPath(); let fen = p(-1.7, 0, 0.8); targetCtx.arc(fen.x, fen.y, 3 * s, 0, 7); targetCtx.fill();
            targetCtx.strokeStyle = "rgba(220, 245, 255, 0.5)"; targetCtx.lineWidth = 2;
            let hub = p(0, 0, 0.7);
            for(let i=0; i<4; i++) {
                let a = hRotor + i * (Math.PI/2);
                let end = p(Math.cos(a)*1.8, Math.sin(a)*1.8, 0.8);
                targetCtx.beginPath(); targetCtx.moveTo(hub.x, hub.y); targetCtx.lineTo(end.x, end.y); targetCtx.stroke();
            }
        } else if (type === 'jayhawk') {
            if(isShadow) {
                targetCtx.fillStyle = `rgba(0,0,0,${Math.max(0, 0.4 - (hZ - getGround(hX, hY))*0.08)})`;
                let sN = p(1.3,0,0); let sT = p(-2.8,0,0); let sL=p(0,0.5,0); let sR=p(0,-0.5,0);
                targetCtx.beginPath(); targetCtx.moveTo(sN.x, sN.y); targetCtx.lineTo(sR.x, sR.y); targetCtx.lineTo(sT.x, sT.y); targetCtx.lineTo(sL.x, sL.y); targetCtx.fill();
                return;
            }
            targetCtx.fillStyle = "#111"; let stabL = p(-2.4, 0.6, 0.3); let stabR = p(-2.4, -0.6, 0.3);
            targetCtx.lineWidth = 4*s; targetCtx.strokeStyle = "#222"; targetCtx.beginPath(); targetCtx.moveTo(stabL.x, stabL.y); targetCtx.lineTo(stabR.x, stabR.y); targetCtx.stroke();
            targetCtx.fillStyle = "#ff6600"; targetCtx.strokeStyle = "#dd3300"; targetCtx.lineWidth = 1;
            let n = p(1.3, 0, 0.3); let tailBoomStart = p(-1.1, 0, 0.6); 
            let bodyFL = p(0.4, 0.45, 0.4); let bodyFR = p(0.4, -0.45, 0.4); let bodyBL = p(-1.0, 0.45, 0.4); let bodyBR = p(-1.0, -0.45, 0.4);
            targetCtx.beginPath(); targetCtx.moveTo(n.x, n.y); targetCtx.lineTo(bodyFR.x, bodyFR.y); targetCtx.lineTo(bodyBR.x, bodyBR.y); targetCtx.lineTo(tailBoomStart.x, tailBoomStart.y); targetCtx.lineTo(bodyBL.x, bodyBL.y); targetCtx.lineTo(bodyFL.x, bodyFL.y); targetCtx.fill(); targetCtx.stroke();
            targetCtx.fillStyle = "#111";
            let doorL1 = p(0.3, 0.47, 0.35); let doorL2 = p(-0.6, 0.47, 0.35); let doorR1 = p(0.3, -0.47, 0.35); let doorR2 = p(-0.6, -0.47, 0.35); 
            targetCtx.beginPath(); targetCtx.moveTo(doorL1.x, doorL1.y); targetCtx.lineTo(doorL2.x, doorL2.y); targetCtx.lineTo(p(-0.6, 0.3, 0.6).x, p(-0.6, 0.3, 0.6).y); targetCtx.lineTo(p(0.3, 0.3, 0.6).x, p(0.3, 0.3, 0.6).y); targetCtx.fill();
            targetCtx.beginPath(); targetCtx.moveTo(doorR1.x, doorR1.y); targetCtx.lineTo(doorR2.x, doorR2.y); targetCtx.lineTo(p(-0.6, -0.3, 0.6).x, p(-0.6, -0.3, 0.6).y); targetCtx.lineTo(p(0.3, -0.3, 0.6).x, p(0.3, -0.3, 0.6).y); targetCtx.fill();
            targetCtx.fillStyle = "#111"; targetCtx.beginPath(); targetCtx.moveTo(n.x, n.y); targetCtx.lineTo(p(0.6, 0.4, 0.6).x, p(0.6, 0.4, 0.6).y); targetCtx.lineTo(p(0.6, -0.4, 0.6).x, p(0.6, -0.4, 0.6).y); targetCtx.fill();
            targetCtx.fillStyle = "#eee"; targetCtx.beginPath(); targetCtx.moveTo(p(0.6, 0, 0.7).x, p(0.6, 0, 0.7).y); targetCtx.lineTo(p(-0.8, 0.35, 0.7).x, p(-0.8, 0.35, 0.7).y); targetCtx.lineTo(p(-0.8, -0.35, 0.7).x, p(-0.8, -0.35, 0.7).y); targetCtx.fill();
            targetCtx.fillStyle = "#ff6600"; let finBase = p(-2.4, 0, 0.6); let finTop = p(-2.9, 0, 1.3); let finBack = p(-3.0, 0, 0.6);
            targetCtx.lineWidth = 6 * s; targetCtx.strokeStyle = "#ff6600"; targetCtx.beginPath(); targetCtx.moveTo(tailBoomStart.x, tailBoomStart.y); targetCtx.lineTo(finBase.x, finBase.y); targetCtx.stroke(); 
            targetCtx.lineWidth = 1; targetCtx.beginPath(); targetCtx.moveTo(finBase.x, finBase.y); targetCtx.lineTo(finTop.x, finTop.y); targetCtx.lineTo(finBack.x, finBack.y); targetCtx.fill();
            targetCtx.strokeStyle = "rgba(220, 245, 255, 0.5)"; targetCtx.lineWidth = 3*s; 
            let hub = p(0, 0, 0.8);
            for(let i=0; i<4; i++) {
                let a = hRotor + i * (Math.PI/2);
                let end = p(Math.cos(a)*2.6, Math.sin(a)*2.6, 0.85); 
                targetCtx.beginPath(); targetCtx.moveTo(hub.x, hub.y); targetCtx.lineTo(end.x, end.y); targetCtx.stroke();
            }
        } else {
            // CLASSIC
            let pN = p(0.8, 0, 0); let pL = p(0, 0.4, 0); let pR = p(0, -0.4, 0); let pB = p(-0.6, 0, 0); let pT = p(-1.8, 0, 0.4); 
            if(isShadow) {
                targetCtx.fillStyle = `rgba(0,0,0,${Math.max(0, 0.4 - (hZ - getGround(hX, hY))*0.08)})`;
                targetCtx.beginPath(); targetCtx.moveTo(pN.x, pN.y); targetCtx.lineTo(pL.x, pL.y); targetCtx.lineTo(pT.x, pT.y); targetCtx.lineTo(pR.x, pR.y); targetCtx.fill();
                return;
            }
            targetCtx.strokeStyle = "#ff6600"; targetCtx.lineWidth = 5 * s;
            targetCtx.beginPath(); targetCtx.moveTo(pB.x, pB.y); targetCtx.lineTo(pT.x, pT.y); targetCtx.stroke();
            targetCtx.fillStyle = "#ff6600"; targetCtx.beginPath(); targetCtx.moveTo(pN.x, pN.y); targetCtx.lineTo(pL.x, pL.y); targetCtx.lineTo(pR.x, pR.y); targetCtx.fill();
            targetCtx.fillStyle = "#fff"; targetCtx.beginPath(); targetCtx.moveTo(pL.x, pL.y); targetCtx.lineTo(pB.x, pB.y); targetCtx.lineTo(pR.x, pR.y); targetCtx.fill();
            targetCtx.strokeStyle = "rgba(220, 245, 255, 0.5)"; targetCtx.lineWidth = 3 * s;
            for(let i=0; i<2; i++) {
                let ang = hRotor + (i * Math.PI);
                let rS = p(-Math.cos(ang)*1.6, -Math.sin(ang)*1.6, 0.45);
                let rE = p(Math.cos(ang)*1.6, Math.sin(ang)*1.6, 0.45);
                targetCtx.beginPath(); targetCtx.moveTo(rS.x, rS.y); targetCtx.lineTo(rE.x, rE.y); targetCtx.stroke();
            }
        }
    }

    function drawPadLights(cx, cy) {
        const lights = [{x: PAD.xMin+0.5, y: PAD.yMin+0.5}, {x: PAD.xMax+0.5, y: PAD.yMin+0.5}, {x: PAD.xMax+0.5, y: PAD.yMax+0.5}, {x: PAD.xMin+0.5, y: PAD.yMax+0.5}];
        let blink = Math.floor(Date.now() / 500) % 2 === 0;
        lights.forEach(l => {
            let p = iso(l.x, l.y, 0.5, cx, cy);
            ctx.fillStyle = blink ? "#f00" : "#500"; ctx.beginPath(); ctx.arc(p.x, p.y, blink?3:2.5, 0, 7); ctx.fill();
        });
    }

    function drawWindsock(cx, cy) {
        let wx = PAD.xMin - 1, wy = PAD.yMin + 1; 
        let base = iso(wx, wy, getGround(wx, wy), cx, cy);
        let top = iso(wx, wy, getGround(wx, wy) + 1.2, cx, cy);
        ctx.strokeStyle = "#aaa"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(base.x, base.y); ctx.lineTo(top.x, top.y); ctx.stroke();
        let wIsoX = (Math.cos(windAngle) - Math.sin(windAngle)) * (tileW/2);
        let wIsoY = (Math.cos(windAngle) + Math.sin(windAngle)) * (tileH/2);
        let len = Math.hypot(wIsoX, wIsoY); wIsoX = (wIsoX / len) * 5; wIsoY = (wIsoY / len) * 5;
        let phase = Date.now() * 0.005;
        ctx.fillStyle = "orange"; ctx.beginPath(); ctx.moveTo(top.x, top.y);
        let cxW = top.x, cyW = top.y;
        for(let i=0; i<4; i++) { 
            let bend = Math.sin(phase + i * 0.5) * 1.5; 
            cxW += wIsoX; cyW += wIsoY + bend * 0.3; ctx.lineTo(cxW, cyW); 
        }
        ctx.lineTo(top.x, top.y + 3); ctx.fill();
    }

    function drawPayloadObject() {
        if (payload.rescued && !payload.hanging) return;
        let p = iso(payload.x, payload.y, payload.z, cam.x, cam.y);
        if (payload.type === 'crate') {
            ctx.fillStyle = "#d84"; ctx.strokeStyle = "#530"; ctx.lineWidth=1;
            let s = 14; 
            ctx.fillRect(p.x - s/2, p.y - s, s, s); ctx.strokeRect(p.x - s/2, p.y - s, s, s);
        } else {
            ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, 7); ctx.fill();
            if(payload.z < 0) { ctx.strokeStyle="#aaf"; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, 7); ctx.stroke(); }
        }
        if (payload.hanging) {
            let hPos = iso(heli.x, heli.y, heli.z, cam.x, cam.y);
            ctx.strokeStyle = (payload.type === 'crate' && heli.type === 'dolphin') ? "#f55" : "#aaa"; 
            ctx.lineWidth = 1.5; ctx.beginPath();
            ctx.moveTo(hPos.x, hPos.y); ctx.lineTo(p.x, p.y); ctx.stroke();
        }
    }

    function renderRain() {
        if (!stormActive) return;
        ctx.strokeStyle = 'rgba(150, 200, 255, 0.4)'; ctx.lineWidth = 1; ctx.beginPath();
        let sx = (wind.x / tileW) * 4000; let sy = (wind.y / tileH) * 4000;
        for(let i=0; i<100; i++) {
            let rx = Math.random() * canvas.width; let ry = Math.random() * canvas.height;
            ctx.moveTo(rx, ry); ctx.lineTo(rx + sx, ry + 15 + Math.abs(sy));
        }
        ctx.stroke();
        if (Math.random() < 0.005) {
            let el = document.getElementById('flash-overlay'); el.style.opacity = 0.8;
            setTimeout(() => el.style.opacity = 0, 100);
        }
    }

    function drawScene() {
        if(!gameStarted || crashed) return;
        updatePhysics();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if(!introActive) {
            let tx = (heli.x - heli.y) * (tileW/2); let ty = (heli.x + heli.y) * (tileH/2);
            cam.x += (tx - cam.x)*0.1; cam.y += (ty - cam.y)*0.1;
        } else {
            introProgress += 0.005; 
            const startX = 23.0; const startY = 17.5;
            heli.x = startX + (START_POS.x - startX) * introProgress; heli.y = startY + (START_POS.y - startY) * introProgress;
            heli.z = 0.5; heli.angle = -Math.PI / 4; heli.rotorRPM = 0; 
            if(introProgress >= 1) { introActive = false; heli.engineOn = false; heli.rotorRPM = 0; heli.x = START_POS.x; heli.y = START_POS.y; showMsg("SYSTEM READY - START ENGINE [W]"); }
        }
        let rx = introActive ? START_POS.x : heli.x; let ry = introActive ? START_POS.y : heli.y;

        for (let x = Math.floor(rx - 12); x < rx + 12; x++) {
            for (let y = Math.floor(ry - 12); y < ry + 12; y++) {
                if(x < 0 || y < 0 || x >= gridSize-1 || y >= gridSize-1) continue;
                let h = [points[x][y], points[x+1][y], points[x+1][y+1], points[x][y+1]];
                let p = [iso(x,y,h[0],cam.x,cam.y), iso(x+1,y,h[1],cam.x,cam.y), iso(x+1,y+1,h[2],cam.x,cam.y), iso(x,y+1,h[3],cam.x,cam.y)];
                let isPad = (x>=PAD.xMin && x<=PAD.xMax && y>=PAD.yMin && y<=PAD.yMax);
                let c = 35 + Math.floor(h[0] * 15);
                let fill = isPad ? "#444" : (h[0]>0 ? `rgb(${c-10},${c+30},${c-10})` : "#003d7a");
                if(stormActive && h[0]<0) fill = "#002244";
                ctx.fillStyle = fill; ctx.beginPath(); ctx.moveTo(p[0].x, p[0].y); ctx.lineTo(p[1].x, p[1].y); ctx.lineTo(p[2].x, p[2].y); ctx.lineTo(p[3].x, p[3].y); ctx.fill();
            }
        }
        
        drawPadLights(cam.x, cam.y);
        drawWindsock(cam.x, cam.y);
        drawHangar(cam.x, cam.y);
        
        drawHeli(heli.type, heli.x, heli.y, heli.z, heli.angle, heli.tilt, heli.roll, heli.rotationPos, cam.x, cam.y, ctx, canvas, true);
        
        particles.forEach(p => { 
            let pos = iso(p.x, p.y, p.z, cam.x, cam.y); 
            ctx.fillStyle = `rgba(${p.color}, ${p.life})`; 
            ctx.fillRect(pos.x, pos.y, 3, 3); 
        });

        drawPayloadObject();

        if(!payload.hanging) {
            let hP = iso(heli.x, heli.y, heli.z, cam.x, cam.y);
            let wP = iso(heli.x, heli.y, Math.max(getGround(heli.x, heli.y), heli.z - heli.winch), cam.x, cam.y);
            ctx.strokeStyle = "#bbb"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(hP.x, hP.y); ctx.lineTo(wP.x, wP.y); ctx.stroke();
        }
        
        drawHeli(heli.type, heli.x, heli.y, heli.z, heli.angle, heli.tilt, heli.roll, heli.rotationPos, cam.x, cam.y, ctx, canvas, false);
        renderRain();

        if(!introActive) {
            ctx.font = "bold 13px monospace"; ctx.fillStyle = "#5f5";
            let hX = iso(heli.x, heli.y, heli.z, cam.x, cam.y).x + 45, hY = iso(heli.x, heli.y, heli.z, cam.x, cam.y).y - 35;
            ctx.fillText(`ALT: ${Math.round((heli.z-getGround(heli.x, heli.y))*10)}m`, hX, hY);
            ctx.fillText(`WINCH: ${Math.round(heli.winch*10)}m`, hX, hY + 16);
            ctx.fillStyle = heli.fuel < 20 ? "#f00" : "#5f5";
            ctx.fillText(`FUEL: ${Math.max(0, Math.round(heli.fuel))}%`, hX, hY + 32);
            ctx.fillStyle = "#5f5";
            let lbl = (missionType === 'recovery') ? "CRATES:" : "SAVED:";
            ctx.fillText(`${lbl} ${totalRescued}/${goalCount}`, hX, hY + 48);

            const ms = 140, mp = 20, bx = canvas.width - ms - mp, by = canvas.height - ms - mp;
            const sc = ms / gridSize;
            ctx.fillStyle = "rgba(0,20,10,0.8)"; ctx.fillRect(bx, by, ms, ms);
            ctx.strokeStyle = "#5f5"; ctx.strokeRect(bx, by, ms, ms);
            ctx.fillStyle = "#666"; ctx.fillRect(bx + PAD.xMin * sc, by + PAD.yMin * sc, (PAD.xMax - PAD.xMin) * sc, (PAD.yMax - PAD.yMin) * sc);
            ctx.fillStyle = "#fff"; ctx.fillRect(bx + heli.x * sc - 1.5, by + heli.y * sc - 1.5, 3, 3);
            if(!payload.rescued && !payload.hanging) {
                ctx.fillStyle = payload.type === 'crate' ? "#d84" : "#f00";
                ctx.beginPath(); ctx.arc(bx + payload.x * sc, by + payload.y * sc, 2, 0, 7); ctx.fill();
            }
        }
        requestAnimationFrame(drawScene);
    }

    function startGame(type) {
        if(gameStarted) return;
        heli.type = type;
        if(type === 'dolphin') { 
            heli.maxLoad = 3; heli.accel = 0.0035; heli.friction = 0.97; heli.tiltSpeed = 0.05; heli.fuelRate = 0.012; heli.liftPower = 0.0009; 
            heli.cargoResist = 2.0; 
        } else if(type === 'jayhawk') { 
            heli.maxLoad = 10; heli.accel = 0.0010; heli.friction = 0.995; heli.tiltSpeed = 0.015; heli.fuelRate = 0.007; heli.liftPower = 0.0005; 
            heli.cargoResist = 0.3; 
        } else { 
            heli.maxLoad = 5; heli.accel = 0.0020; heli.friction = 0.99; heli.tiltSpeed = 0.02; heli.fuelRate = 0.010; heli.liftPower = 0.0007; 
            heli.cargoResist = 1.0; 
        }

        generateTerrain();
        
        document.getElementById('heli-select').style.display = 'none';
        gameStarted = true; introActive = true; introProgress = 0;
        cam.x = (START_POS.x - START_POS.y) * (tileW / 2); cam.y = (START_POS.x + START_POS.y) * (tileH / 2);
        totalRescued = 0; 
        payload.rescued=true; payload.hanging=false; 
        spawnPayload(); 
        
        drawScene();
    }

    function drawMenuHeli() {
        if(gameStarted) return;
        const c = document.getElementById('menu-heli-big'); if(!c) return;
        const cx = c.getContext('2d'); c.width = 800; c.height = 300; cx.clearRect(0,0,c.width,c.height);
        const t = Date.now() * 0.001;
        drawHeli('classic', 0, 0, 0.8, t*0.5, Math.sin(t)*0.1, Math.cos(t)*0.1, t*12, 0, 0, cx, c, false, 3.5);
        if(document.getElementById('splash').style.display !== 'none') requestAnimationFrame(drawMenuHeli);
    }
    drawMenuHeli();

    function animateHeliPreviews() {
        if(document.getElementById('heli-select').style.display === 'none') return;
        const t = Date.now() * 0.001;
        const c1 = document.getElementById('icon-classic'); if(c1) { const cx1 = c1.getContext('2d'); c1.width=300; c1.height=200; cx1.clearRect(0,0,300,200); drawHeli('classic', 0, 0, 0, t*0.5, Math.sin(t)*0.1, Math.cos(t)*0.1, t*12, 0, 0, cx1, c1, false, 2.5); }
        const c2 = document.getElementById('icon-dolphin'); if(c2) { const cx2 = c2.getContext('2d'); c2.width=300; c2.height=200; cx2.clearRect(0,0,300,200); drawHeli('dolphin', 0, 0, 0, t*0.5, Math.sin(t)*0.1, Math.cos(t)*0.1, t*12, 0, 0, cx2, c2, false, 2.5); }
        const c3 = document.getElementById('icon-jayhawk'); if(c3) { const cx3 = c3.getContext('2d'); c3.width=300; c3.height=200; cx3.clearRect(0,0,300,200); drawHeli('jayhawk', 0, 0, 0, t*0.5, Math.sin(t)*0.1, Math.cos(t)*0.1, t*12, 0, 0, cx3, c3, false, 2.5); }
        requestAnimationFrame(animateHeliPreviews);
    }

    window.onkeydown = (e) => keys[e.code] = true;
    window.onkeyup = (e) => keys[e.code] = false;
    window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
    window.onresize();
</script>
</body>
</html>
