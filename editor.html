<!doctype html>
<html>
    <head>
        <title>ZEEWOLF - Mission Builder & 3D Editor (Click UIs)</title>
        <style>
            body {
                background: #181818;
                color: #fff;
                font-family: monospace;
                display: flex;
                flex-direction: column;
                align-items: center;
                padding-bottom: 50px;
                margin: 0;
            }
            h2 {
                margin-top: 10px;
                margin-bottom: 10px;
                color: #ff6600;
                text-shadow: 0 0 10px #ff6600;
            }

            .workspace {
                display: flex;
                gap: 20px;
                justify-content: center;
                align-items: flex-start;
                margin-top: 10px;
            }
            .canvas-container {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .editor-wrapper {
                position: relative;
                width: 600px;
                height: 600px;
                overflow: hidden;
                border: 2px solid #5f5;
                background: #002244;
            }

            canvas {
                display: block;
            }
            #previewCanvas {
                border: 2px solid #5f5;
                background: #001122;
                cursor: grab;
            }
            #previewCanvas:active {
                cursor: grabbing;
            }

            .floating-ui {
                position: absolute;
                background: rgba(17, 17, 17, 0.9);
                border: 1px solid #5f5;
                padding: 10px;
                font-size: 12px;
                color: #fff;
                border-radius: 4px;
                pointer-events: auto;
                z-index: 10;
                box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(4px);
                display: none;
            }
            .floating-ui input,
            .floating-ui select {
                font-size: 11px;
                padding: 2px;
                height: 20px;
                margin-top: 4px;
            }
            .close-btn {
                float: right;
                cursor: pointer;
                color: #f55;
                font-weight: bold;
                margin-left: 10px;
            }
            .close-btn:hover {
                color: #fff;
            }

            .controls,
            .mission-config,
            .tool-bar {
                margin-top: 15px;
                text-align: left;
                max-width: 1120px;
                width: 100%;
                box-sizing: border-box;
                background: #222;
                border: 1px solid #5f5;
                padding: 15px;
            }
            input[type='text'],
            input[type='number'],
            textarea,
            select {
                background: #111;
                color: #5f5;
                border: 1px solid #5f5;
                padding: 5px;
                font-family: monospace;
                box-sizing: border-box;
                margin-top: 5px;
            }
            .flex-row {
                display: flex;
                gap: 15px;
                margin-top: 10px;
                align-items: flex-start;
                flex-wrap: wrap;
            }
            .flex-col {
                flex: 1;
            }

            button {
                background: #5f5;
                color: #000;
                border: none;
                padding: 8px 15px;
                font-weight: bold;
                cursor: pointer;
                margin: 2px;
            }
            button:hover {
                background: #fff;
            }
            label {
                margin: 0 10px 0 0;
                cursor: pointer;
                font-size: 14px;
                display: inline-block;
                margin-bottom: 5px;
            }
            hr {
                border-color: #444;
                margin: 15px 0;
            }
            #output {
                width: 100%;
                height: 100px;
                margin-top: 10px;
            }

            .weather-box {
                background: #1a1a1a;
                padding: 15px;
                border: 1px dashed #0cf;
                border-radius: 5px;
                margin-top: 10px;
            }
        </style>
    </head>
    <body>
        <h2>ZEEWOLF Mission Builder</h2>

        <div class="tool-bar">
            <div class="flex-row" style="margin-top: 0; align-items: flex-start">
                <div class="flex-col">
                    <strong>WERKZEUG:</strong><br />
                    <label
                        ><input type="radio" name="tool" value="move" onchange="setTool('move')" /> ‚úã Bewegen
                        (Drag)</label
                    ><br />
                    <label
                        ><input type="radio" name="tool" value="terrain" checked onchange="setTool('terrain')" /> ‚õ∞Ô∏è
                        Terrain (Shift: Runter)</label
                    ><br />
                    <label
                        ><input type="radio" name="tool" value="flatten" onchange="setTool('flatten')" /> üßΩ Einebnen
                        (Shift: Wasser)</label
                    ><br />
                    <label><input type="radio" name="tool" value="pad" onchange="setTool('pad')" /> üöÅ Pad</label><br />
                    <label
                        ><input type="radio" name="tool" value="lighthouse" onchange="setTool('lighthouse')" /> üóº
                        Turm</label
                    ><br />
                    <label
                        ><input type="radio" name="tool" value="carrier" onchange="setTool('carrier')" /> üö¢ Tr√§ger
                        (Shift: L√∂sch)</label
                    >
                </div>

                <div class="flex-col" style="border-left: 1px solid #5f5; padding-left: 15px">
                    <strong>PINSEL:</strong><br />
                    <label
                        ><input
                            type="radio"
                            name="brush"
                            value="0"
                            onchange="
                                brushRadius = 0;
                                isCustomBrush = false;
                            "
                        />
                        Klein (1)</label
                    ><br />
                    <label
                        ><input
                            type="radio"
                            name="brush"
                            value="1.5"
                            checked
                            onchange="
                                brushRadius = 1.5;
                                isCustomBrush = false;
                            "
                        />
                        Mittel (3)</label
                    ><br />
                    <label
                        ><input
                            type="radio"
                            name="brush"
                            value="5.0"
                            onchange="
                                brushRadius = 5.0;
                                isCustomBrush = false;
                            "
                        />
                        Gro√ü (10)</label
                    ><br />
                    <label
                        ><input
                            type="radio"
                            name="brush"
                            value="15.0"
                            onchange="
                                brushRadius = 15.0;
                                isCustomBrush = false;
                            "
                        />
                        Riesig (30)</label
                    ><br />
                    <label
                        ><input
                            type="radio"
                            name="brush"
                            value="custom"
                            onchange="
                                isCustomBrush = true;
                                updateCustomBrush();
                            "
                        />
                        Frei Radius:
                        <input
                            type="number"
                            id="m_custom_brush"
                            value="8"
                            min="1"
                            max="50"
                            style="width: 50px"
                            oninput="updateCustomBrush()"
                        />
                    </label>
                </div>

                <div class="flex-col" style="border-left: 1px solid #5f5; padding-left: 15px">
                    <strong>ANSICHT (2D):</strong><br />
                    <span style="font-size: 11px; color: #aaa">(Mausrad = Zoom!)</span><br />
                    <button onclick="changeZoom(0.5)">Zoom +</button> <button onclick="changeZoom(-0.5)">Zoom -</button>
                </div>

                <div class="flex-col" style="border-left: 1px solid #5f5; padding-left: 15px">
                    <strong>MAP GR√ñSSE:</strong><br />
                    <input
                        type="number"
                        id="m_grid_size"
                        value="100"
                        step="10"
                        min="50"
                        max="400"
                        style="width: 70px"
                    />
                    <button onclick="resizeMap()">Anwenden</button><br /><br />
                </div>
            </div>
        </div>

        <div class="workspace">
            <div class="canvas-container">
                <strong style="margin-bottom: 5px"
                    >2D Editor
                    <span style="font-size: 11px; color: #aaa">(Klick auf Pad/Tr√§ger/Kompass f√ºr Details)</span></strong
                >

                <div class="editor-wrapper">
                    <canvas id="editorCanvas" width="600" height="600"></canvas>

                    <div
                        id="ui_wind"
                        class="floating-ui"
                        style="left: 90px; top: 15px"
                        onmousedown="event.stopPropagation()"
                        onwheel="event.stopPropagation()"
                    >
                        <span
                            class="close-btn"
                            onclick="
                                selectedUI = null;
                                drawMap();
                            "
                            >‚úñ</span
                        >
                        <strong style="color: cyan">üí® WIND KONTROLLE</strong><br />
                        Richt. (¬∞):
                        <input
                            type="number"
                            id="m_wind_dir"
                            value="45"
                            min="0"
                            max="359"
                            style="width: 50px"
                            oninput="
                                drawMap();
                                drawPreview();
                            "
                        /><br />
                        St√§rke: &nbsp;&nbsp;<input
                            type="number"
                            id="m_wind_str"
                            value="1.0"
                            step="0.1"
                            min="0"
                            style="width: 50px"
                            oninput="
                                drawMap();
                                drawPreview();
                            "
                        /><br />
                        <label style="margin-top: 5px"
                            ><input type="checkbox" id="m_wind_var" onchange="drawMap()" /> Variabel (Pendeln)</label
                        >
                    </div>

                    <div
                        id="ui_carrier"
                        class="floating-ui"
                        onmousedown="event.stopPropagation()"
                        onwheel="event.stopPropagation()"
                    >
                        <span
                            class="close-btn"
                            onclick="
                                selectedUI = null;
                                drawMap();
                            "
                            >‚úñ</span
                        >
                        <strong style="color: #88aaff">üö¢ TR√ÑGER SETTINGS</strong> <br /><br />
                        <button
                            id="btn_spawn_carrier"
                            onclick="setSpawn('carrier')"
                            style="padding: 4px 8px; font-size: 11px; width: 100%"
                        >
                            Als Startpunkt setzen</button
                        ><br />
                        Winkel (¬∞):
                        <input
                            type="number"
                            id="m_carrier_angle"
                            value="0"
                            min="0"
                            max="359"
                            style="width: 50px"
                            oninput="
                                carrierAngle = parseInt(this.value) || 0;
                                drawMap();
                                drawPreview();
                            "
                        /><br />
                        Speed (kn):
                        <input
                            type="number"
                            id="m_carrier_speed"
                            value="0.0"
                            step="0.5"
                            style="width: 50px"
                            oninput="drawMap()"
                        /><br />
                        Route: &nbsp;&nbsp;&nbsp;&nbsp;<select
                            id="m_carrier_path"
                            onchange="drawMap()"
                            style="width: 80px"
                        >
                            <option value="static">Anker</option>
                            <option value="straight">Gerade</option>
                            <option value="circle">Kreis</option></select
                        ><br />
                        Radius: &nbsp;&nbsp;&nbsp;<input
                            type="number"
                            id="m_carrier_radius"
                            value="40"
                            step="5"
                            style="width: 50px"
                            oninput="drawMap()"
                        />
                        Grid
                    </div>

                    <div
                        id="ui_pad"
                        class="floating-ui"
                        onmousedown="event.stopPropagation()"
                        onwheel="event.stopPropagation()"
                    >
                        <span
                            class="close-btn"
                            onclick="
                                selectedUI = null;
                                drawMap();
                            "
                            >‚úñ</span
                        >
                        <strong style="color: #5f5">üöÅ LANDING PAD</strong> <br /><br />
                        <button
                            id="btn_spawn_pad"
                            onclick="setSpawn('pad')"
                            style="padding: 4px 8px; font-size: 11px; width: 100%"
                        >
                            Als Startpunkt setzen
                        </button>
                    </div>
                </div>
            </div>
            <div class="canvas-container">
                <strong style="margin-bottom: 5px"
                    >3D Engine Preview
                    <span style="font-size: 11px; color: #aaa">(Drag = Pan | D-Klick = Reset)</span></strong
                >
                <canvas id="previewCanvas" width="500" height="600"></canvas>
            </div>
        </div>

        <div class="mission-config">
            <strong>MISSION CONFIGURATION</strong>
            <div class="flex-row">
                <div class="flex-col">
                    <label
                        >Headline:<input type="text" id="m_headline" value="CUSTOM MISSION" style="width: 100%"
                    /></label>
                    <label
                        >Sublines (1 pro Zeile):
                        <textarea id="m_sublines" style="height: 50px">
Editor Map
Sichere die Ziele!</textarea
                        >
                    </label>
                </div>
                <div class="flex-col">
                    <strong>ZIELSICHERUNG:</strong><br /><br />
                    <label>Personen: <input type="number" id="m_persons" value="5" min="0" style="width: 50px" /></label
                    ><br />
                    <label
                        >Kisten: &nbsp;&nbsp;<input type="number" id="m_crates" value="0" min="0" style="width: 50px"
                    /></label>
                </div>
            </div>

            <div class="weather-box">
                <strong style="color: #0cf">WETTER & UMGEBUNG</strong>
                <span style="font-size: 11px; color: #aaa">(Wind ist auf der 2D Karte am Kompass einstellbar)</span
                ><br />
                <div style="margin-top: 10px">
                    <label><input type="checkbox" id="m_rain" onchange="drawPreview()" /> üåßÔ∏è Regen / Sturm</label>
                    &nbsp;&nbsp;&nbsp;
                    <label><input type="checkbox" id="m_night" onchange="drawPreview()" /> üåô Nachtmodus</label>
                </div>
            </div>
        </div>

        <div class="controls" style="text-align: center">
            <button onclick="exportMap()" style="padding: 15px 30px; font-size: 16px">‚¨ÜÔ∏è Map Exportieren</button>
            <button onclick="importMap()" style="padding: 15px 30px; font-size: 16px">‚¨áÔ∏è Map Importieren</button>
            <button onclick="clearMap()" style="background: #f55; color: white; padding: 15px 30px; font-size: 16px">
                üóëÔ∏è Reset
            </button>
            <br />
            <textarea id="output" placeholder="Code zum Importieren hier einf√ºgen..."></textarea>
        </div>

        <script>
            const canvas = document.getElementById('editorCanvas');
            const ctx = canvas.getContext('2d');
            const prevCanvas = document.getElementById('previewCanvas');
            const prevCtx = prevCanvas.getContext('2d');

            let gridSize = 100;

            // --- 2D Kamera ---
            let zoom = 1.0;
            let panX = 0;
            let panY = 0;

            // --- 3D Kamera ---
            let prevZoom = 1.0;
            let prevPanX = 0;
            let prevPanY = 0;
            let isPrevDragging = false;
            let lastPrevMouseX = 0;
            let lastPrevMouseY = 0;

            let points = [];
            let padX = 10,
                padY = 10;
            let carrierX = -1,
                carrierY = -1,
                carrierAngle = 0;
            let lighthouseX = -1,
                lighthouseY = -1;

            let spawnPoint = 'pad';
            let selectedUI = null;

            let isDrawing = false;
            let isEditorDragging = false;
            let lastEditorMouseX = 0;
            let lastEditorMouseY = 0;

            let currentTool = 'terrain';
            let brushRadius = 1.5;
            let isCustomBrush = false;

            function setTool(toolName) {
                currentTool = toolName;
                if (toolName === 'move') {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }

            function updateCustomBrush() {
                if (isCustomBrush) brushRadius = parseFloat(document.getElementById('m_custom_brush').value) || 8;
            }

            // --- SPAWN LOGIK ---
            function setSpawn(target) {
                spawnPoint = target;
                drawMap();
            }

            function checkSpawnFallback() {
                if (spawnPoint === 'pad' && padX < 0) {
                    if (carrierX >= 0) spawnPoint = 'carrier';
                } else if (spawnPoint === 'carrier' && carrierX < 0) {
                    if (padX >= 0) spawnPoint = 'pad';
                }
            }

            // --- MAP INITIALISIEREN / RESIZE ---
            function initMap() {
                points = [];
                gridSize = parseInt(document.getElementById('m_grid_size').value) || 100;
                zoom = 1.0;
                panX = 0;
                panY = 0;
                prevZoom = 1.0;
                prevPanX = 0;
                prevPanY = 0;

                for (let x = 0; x <= gridSize; x++) {
                    points[x] = [];
                    for (let y = 0; y <= gridSize; y++) {
                        points[x][y] = 0;
                    }
                }
                padX = 10;
                padY = 10;
                carrierX = -1;
                carrierY = -1;
                carrierAngle = 0;
                lighthouseX = -1;
                lighthouseY = -1;
                spawnPoint = 'pad';
                selectedUI = null;

                drawMap();
                drawPreview();
                document.getElementById('output').value = '';
            }

            function resizeMap() {
                let newSize = parseInt(document.getElementById('m_grid_size').value);
                if (newSize < 20 || newSize > 400) return alert('Grid Size muss zwischen 20 und 400 liegen.');

                let oldPoints = points;
                let oldSize = gridSize;
                gridSize = newSize;
                clampCamera();

                points = [];
                for (let x = 0; x <= gridSize; x++) {
                    points[x] = [];
                    for (let y = 0; y <= gridSize; y++) {
                        if (x <= oldSize && y <= oldSize && oldPoints[x]) {
                            points[x][y] = oldPoints[x][y] !== undefined ? oldPoints[x][y] : 0;
                        } else {
                            points[x][y] = -1;
                        }
                    }
                }
                drawMap();
                drawPreview();
            }

            function clampCamera() {
                let currentTileSize = (canvas.width / gridSize) * zoom;
                let viewGridW = canvas.width / currentTileSize;
                let viewGridH = canvas.height / currentTileSize;

                panX = Math.max(0, Math.min(panX, gridSize - viewGridW));
                panY = Math.max(0, Math.min(panY, gridSize - viewGridH));
                if (viewGridW >= gridSize) panX = 0;
                if (viewGridH >= gridSize) panY = 0;
            }

            function changeZoom(amount) {
                zoom = Math.max(1.0, Math.min(zoom + amount, 15.0));
                clampCamera();
                drawMap();
            }

            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                let oldZoom = zoom;
                let currentTileSizeOld = (canvas.width / gridSize) * oldZoom;
                let gridTargetX = mouseX / currentTileSizeOld + panX;
                let gridTargetY = mouseY / currentTileSizeOld + panY;

                if (e.deltaY < 0) zoom += 0.5;
                else zoom -= 0.5;
                zoom = Math.max(1.0, Math.min(zoom, 15.0));

                if (zoom !== oldZoom) {
                    let currentTileSizeNew = (canvas.width / gridSize) * zoom;
                    panX = gridTargetX - mouseX / currentTileSizeNew;
                    panY = gridTargetY - mouseY / currentTileSizeNew;
                    clampCamera();
                    drawMap();
                }
            });

            // --- ZOOM & PAN (3D PREVIEW) ---
            prevCanvas.addEventListener('mousedown', e => {
                isPrevDragging = true;
                lastPrevMouseX = e.clientX;
                lastPrevMouseY = e.clientY;
            });

            prevCanvas.addEventListener('mousemove', e => {
                if (isPrevDragging) {
                    prevPanX += e.clientX - lastPrevMouseX;
                    prevPanY += e.clientY - lastPrevMouseY;
                    lastPrevMouseX = e.clientX;
                    lastPrevMouseY = e.clientY;
                    drawPreview();
                }
            });

            prevCanvas.addEventListener('wheel', e => {
                e.preventDefault();
                const rect = prevCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                if (mouseY > 300) return;

                let oldZoom = prevZoom;
                if (e.deltaY < 0) prevZoom *= 1.2;
                else prevZoom /= 1.2;
                prevZoom = Math.max(1.0, Math.min(prevZoom, 20.0));

                if (prevZoom === 1.0) {
                    prevPanX = 0;
                    prevPanY = 0;
                } else {
                    let scaleRatio = prevZoom / oldZoom;
                    let dx = mouseX - (prevCanvas.width / 2 + prevPanX);
                    let dy = mouseY - (300 * 0.1 + prevPanY);
                    prevPanX = mouseX - prevCanvas.width / 2 - dx * scaleRatio;
                    prevPanY = mouseY - 300 * 0.1 - dy * scaleRatio;
                }
                drawPreview();
            });

            prevCanvas.addEventListener('dblclick', () => {
                prevZoom = 1.0;
                prevPanX = 0;
                prevPanY = 0;
                drawPreview();
            });

            // --- RENDERING 2D ---
            function drawWindCompass() {
                let dir = parseFloat(document.getElementById('m_wind_dir').value) || 0;
                let strength = parseFloat(document.getElementById('m_wind_str').value) || 0;
                let isVar = document.getElementById('m_wind_var').checked;
                let cX = 50;
                let cY = 50;
                let radius = 30;

                if (selectedUI === 'wind') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'cyan';
                }

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(cX, cY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#5f5';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.shadowBlur = 0;

                if (strength > 0) {
                    let rad = dir * (Math.PI / 180);
                    let arrowLen = Math.min(25 + strength * 5, 80);
                    let endX = cX + Math.cos(rad) * arrowLen;
                    let endY = cY + Math.sin(rad) * arrowLen;

                    ctx.strokeStyle = isVar ? 'orange' : 'cyan';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(cX, cY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    let headRad = Math.PI / 6;
                    let headLen = 10;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - Math.cos(rad - headRad) * headLen, endY - Math.sin(rad - headRad) * headLen);
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - Math.cos(rad + headRad) * headLen, endY - Math.sin(rad + headRad) * headLen);
                    ctx.stroke();
                }
            }

            function drawMap() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                let tSize = (canvas.width / gridSize) * zoom;

                let viewW = Math.ceil(canvas.width / tSize) + 1;
                let viewH = Math.ceil(canvas.height / tSize) + 1;
                let startX = Math.floor(panX);
                let startY = Math.floor(panY);
                let endX = Math.min(gridSize, startX + viewW);
                let endY = Math.min(gridSize, startY + viewH);

                for (let x = startX; x < endX; x++) {
                    for (let y = startY; y < endY; y++) {
                        let h = points[x][y];
                        if (h < 0) ctx.fillStyle = '#004488';
                        else if (h === 0) ctx.fillStyle = '#d84';
                        else ctx.fillStyle = `rgb(${50 + h * 20}, ${150 + h * 10}, 50)`;

                        let screenX = (x - panX) * tSize;
                        let screenY = (y - panY) * tSize;
                        ctx.fillRect(screenX, screenY, tSize + 1.5, tSize + 1.5);
                    }
                }

                let pUI = document.getElementById('ui_pad');
                let cUI = document.getElementById('ui_carrier');
                let wUI = document.getElementById('ui_wind');

                // PAD RENDERN
                if (padX >= 0 && padY >= 0) {
                    let pScreenX = (padX - panX) * tSize;
                    let pScreenY = (padY - panY) * tSize;

                    if (selectedUI === 'pad') {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#5f5';
                    }
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                    ctx.strokeStyle = '#5f5';
                    ctx.lineWidth = 2;
                    ctx.fillRect(pScreenX, pScreenY, 8 * tSize, 8 * tSize);
                    ctx.strokeRect(pScreenX, pScreenY, 8 * tSize, 8 * tSize);
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(pScreenX + 4 * tSize, pScreenY + 4 * tSize, Math.max(4, tSize / 2), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    if (spawnPoint === 'pad') {
                        ctx.fillStyle = '#ffcc00';
                        ctx.font = 'bold 14px monospace';
                        ctx.fillText('SPAWN', pScreenX, pScreenY - 5);
                    }

                    if (selectedUI === 'pad') {
                        pUI.style.display = 'block';
                        pUI.style.left = Math.min(canvas.width - 150, Math.max(0, pScreenX + 8 * tSize + 10)) + 'px';
                        pUI.style.top = Math.min(canvas.height - 100, Math.max(0, pScreenY)) + 'px';
                        document.getElementById('btn_spawn_pad').style.background =
                            spawnPoint === 'pad' ? '#ffcc00' : '#5f5';
                    } else pUI.style.display = 'none';
                } else {
                    pUI.style.display = 'none';
                }

                // TR√ÑGER RENDERN
                if (carrierX >= 0 && carrierY >= 0) {
                    let pathType = document.getElementById('m_carrier_path').value;
                    let cScreenX = (carrierX - panX) * tSize;
                    let cScreenY = (carrierY - panY) * tSize;
                    let angleRad = (carrierAngle * Math.PI) / 180;

                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 102, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 8]);
                    if (pathType === 'straight') {
                        ctx.beginPath();
                        ctx.moveTo(cScreenX, cScreenY);
                        ctx.lineTo(cScreenX + Math.cos(angleRad) * 4000, cScreenY + Math.sin(angleRad) * 4000);
                        ctx.stroke();
                    } else if (pathType === 'circle') {
                        let pathRadius = (parseFloat(document.getElementById('m_carrier_radius').value) || 40) * tSize;
                        let centerRad = angleRad + Math.PI / 2;
                        let centerX_px = cScreenX + Math.cos(centerRad) * pathRadius;
                        let centerY_px = cScreenY + Math.sin(centerRad) * pathRadius;
                        ctx.beginPath();
                        ctx.arc(centerX_px, centerY_px, pathRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = 'rgba(255, 102, 0, 0.8)';
                        ctx.fillRect(centerX_px - 3, centerY_px - 3, 6, 6);
                    }
                    ctx.restore();

                    ctx.save();
                    ctx.translate(cScreenX, cScreenY);
                    ctx.rotate(angleRad);
                    if (selectedUI === 'carrier') {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = 'white';
                    }
                    ctx.fillStyle = '#888';
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 2;
                    ctx.fillRect(-6 * tSize, -1.5 * tSize, 12 * tSize, 3 * tSize);
                    ctx.strokeRect(-6 * tSize, -1.5 * tSize, 12 * tSize, 3 * tSize);
                    ctx.shadowBlur = 0;

                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.moveTo(6 * tSize, 0);
                    ctx.lineTo(3 * tSize, -1.5 * tSize);
                    ctx.lineTo(3 * tSize, 1.5 * tSize);
                    ctx.fill();

                    ctx.translate(0, 0);
                    ctx.rotate(-angleRad);
                    let spd = document.getElementById('m_carrier_speed').value;
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 11px monospace';
                    ctx.fillText(spd + 'kn', -15, 4);
                    if (spawnPoint === 'carrier') {
                        ctx.fillStyle = '#ffcc00';
                        ctx.font = 'bold 14px monospace';
                        ctx.fillText('SPAWN', -20, -20);
                    }
                    ctx.restore();

                    if (selectedUI === 'carrier') {
                        cUI.style.display = 'block';
                        cUI.style.left = Math.min(canvas.width - 180, Math.max(0, cScreenX + 20)) + 'px';
                        cUI.style.top = Math.min(canvas.height - 180, Math.max(0, cScreenY + 20)) + 'px';
                        document.getElementById('btn_spawn_carrier').style.background =
                            spawnPoint === 'carrier' ? '#ffcc00' : '#5f5';
                    } else cUI.style.display = 'none';
                } else {
                    cUI.style.display = 'none';
                }

                if (lighthouseX >= 0 && lighthouseY >= 0) {
                    let lScreenX = (lighthouseX + 0.5 - panX) * tSize;
                    let lScreenY = (lighthouseY + 0.5 - panY) * tSize;
                    ctx.fillStyle = '#d22';
                    ctx.beginPath();
                    ctx.arc(lScreenX, lScreenY, tSize * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(lScreenX, lScreenY, tSize * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }

                drawWindCompass();

                if (selectedUI === 'wind') {
                    wUI.style.display = 'block';
                } else {
                    wUI.style.display = 'none';
                }
            }

            // --- ISOMETRIC RENDERING ---
            function renderIsoMap(tCtx, tW, tH, mode, offsetY, zScale, pX, pY) {
                let maxExpectedZ = 15;
                let isoWidthRatio = gridSize;
                let isoHeightRatio = gridSize / 2 + maxExpectedZ * 0.3;

                let fitW = (tW * 0.9) / isoWidthRatio;
                let fitH = (tH * 0.9) / isoHeightRatio;

                let sTW = Math.min(fitW, fitH) * zScale;
                let sTH = sTW / 2;
                let stepH = sTW * 0.3;

                let cX = tW / 2 + pX;
                let cY = tH * 0.1 + offsetY + pY;

                let isNight = document.getElementById('m_night').checked;

                function getIso(vx, vy, vz) {
                    return { x: cX + (vx - vy) * (sTW / 2), y: cY + (vx + vy) * (sTH / 2) - vz * stepH };
                }

                tCtx.lineJoin = 'round';
                let step = mode === 'wireframe' ? Math.max(2, Math.round(gridSize / 25)) : 1;

                for (let x = 0; x < gridSize; x += step) {
                    for (let y = 0; y < gridSize; y += step) {
                        let nx = Math.min(x + step, gridSize);
                        let ny = Math.min(y + step, gridSize);

                        let h0 = points[x][y];
                        let h1 = points[nx] ? points[nx][y] : h0;
                        let h2 = points[nx] && points[nx][ny] ? points[nx][ny] : h0;
                        let h3 = points[x] && points[x][ny] ? points[x][ny] : h0;

                        let p0 = getIso(x, y, h0);
                        let p1 = getIso(nx, y, h1);
                        let p2 = getIso(nx, ny, h2);
                        let p3 = getIso(x, ny, h3);

                        tCtx.beginPath();
                        tCtx.moveTo(p0.x, p0.y);
                        tCtx.lineTo(p1.x, p1.y);
                        tCtx.lineTo(p2.x, p2.y);
                        tCtx.lineTo(p3.x, p3.y);
                        tCtx.closePath();

                        if (mode === 'filled') {
                            let r, g, b;
                            if (h0 < 0) {
                                r = 0;
                                g = 61;
                                b = 122;
                            } else if (h0 === 0) {
                                r = 204;
                                g = 119;
                                b = 51;
                            } else {
                                r = 40 + h0 * 20;
                                g = 130 + h0 * 10;
                                b = 40;
                            }
                            if (isNight) {
                                r = Math.floor(r * 0.3);
                                g = Math.floor(g * 0.4);
                                b = Math.floor(b * 0.6);
                            }

                            tCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                            tCtx.fill();
                            if (h0 > 0) {
                                tCtx.strokeStyle = isNight ? 'rgba(0,0,0,0.4)' : 'rgba(0,0,0,0.1)';
                                tCtx.stroke();
                            }
                        } else if (mode === 'wireframe') {
                            tCtx.strokeStyle = 'rgba(255, 102, 0, 0.5)';
                            tCtx.lineWidth = 1;
                            tCtx.stroke();
                        }
                    }
                }

                if (padX >= 0 && padY >= 0) {
                    let ph = points[padX + 4] ? points[padX + 4][padY + 4] : 0;
                    let pp = getIso(padX + 4, padY + 4, ph > 0 ? ph : 0.5);
                    if (mode === 'filled') {
                        tCtx.fillStyle = isNight ? '#2a2' : '#5f5';
                        tCtx.fillRect(pp.x - 10, pp.y - 5, 20, 10);
                    } else {
                        tCtx.strokeStyle = '#ffcc00';
                        tCtx.lineWidth = 2;
                        tCtx.strokeRect(pp.x - 10, pp.y - 5, 20, 10);
                    }
                }

                if (carrierX >= 0 && carrierY >= 0) {
                    let rad = (carrierAngle * Math.PI) / 180;
                    let cCos = Math.cos(rad);
                    let cSin = Math.sin(rad);
                    let w = 6;
                    let h = 1.5;

                    let p0 = getIso(carrierX + w * cCos - h * cSin, carrierY + w * cSin + h * cCos, 0.5);
                    let p1 = getIso(carrierX - w * cCos - h * cSin, carrierY - w * cSin + h * cCos, 0.5);
                    let p2 = getIso(carrierX - w * cCos + h * cSin, carrierY - w * cSin - h * cCos, 0.5);
                    let p3 = getIso(carrierX + w * cCos + h * cSin, carrierY + w * cSin - h * cCos, 0.5);

                    tCtx.beginPath();
                    tCtx.moveTo(p0.x, p0.y);
                    tCtx.lineTo(p1.x, p1.y);
                    tCtx.lineTo(p2.x, p2.y);
                    tCtx.lineTo(p3.x, p3.y);
                    tCtx.closePath();

                    if (mode === 'filled') {
                        tCtx.fillStyle = isNight ? '#333' : '#888';
                        tCtx.fill();
                        let b0 = getIso(carrierX + 2 * cCos - 1 * cSin, carrierY + 2 * cSin + 1 * cCos, 1.5);
                        tCtx.fillStyle = isNight ? '#222' : '#666';
                        tCtx.fillRect(b0.x - 5, b0.y - 15, 10, 15);
                    } else {
                        tCtx.strokeStyle = '#ffcc00';
                        tCtx.lineWidth = 2;
                        tCtx.stroke();
                        let b0 = getIso(carrierX + 2 * cCos - 1 * cSin, carrierY + 2 * cSin + 1 * cCos, 1.5);
                        tCtx.strokeRect(b0.x - 5, b0.y - 15, 10, 15);
                    }
                }

                if (lighthouseX >= 0 && lighthouseY >= 0) {
                    let lh = points[lighthouseX] ? points[lighthouseX][lighthouseY] : 0;
                    let lp = getIso(lighthouseX, lighthouseY, lh + 4);
                    if (mode === 'filled') {
                        tCtx.fillStyle = isNight ? '#811' : '#d22';
                        tCtx.fillRect(lp.x - 3, lp.y - 25, 6, 25);
                        tCtx.fillStyle = isNight ? '#aaa' : '#fff';
                        tCtx.beginPath();
                        tCtx.arc(lp.x, lp.y - 25, 5, 0, Math.PI * 2);
                        tCtx.fill();
                    } else {
                        tCtx.strokeStyle = '#ffcc00';
                        tCtx.lineWidth = 2;
                        tCtx.strokeRect(lp.x - 3, lp.y - 25, 6, 25);
                        tCtx.beginPath();
                        tCtx.arc(lp.x, lp.y - 25, 5, 0, Math.PI * 2);
                        tCtx.stroke();
                    }
                }
            }

            function drawPreview() {
                prevCtx.clearRect(0, 0, prevCanvas.width, prevCanvas.height);
                let isNight = document.getElementById('m_night').checked;
                let isRain = document.getElementById('m_rain').checked;

                if (isNight || isRain) {
                    prevCtx.fillStyle = isNight ? '#000408' : '#001122';
                    prevCtx.fillRect(0, 0, prevCanvas.width, prevCanvas.height);
                }

                prevCtx.save();
                prevCtx.beginPath();
                prevCtx.rect(0, 0, prevCanvas.width, 300);
                prevCtx.clip();
                renderIsoMap(prevCtx, prevCanvas.width, 300, 'filled', 0, prevZoom, prevPanX, prevPanY);
                prevCtx.restore();

                prevCtx.strokeStyle = '#444';
                prevCtx.lineWidth = 2;
                prevCtx.beginPath();
                prevCtx.moveTo(0, 300);
                prevCtx.lineTo(500, 300);
                prevCtx.stroke();

                prevCtx.save();
                prevCtx.beginPath();
                prevCtx.rect(0, 300, prevCanvas.width, 300);
                prevCtx.clip();
                renderIsoMap(prevCtx, prevCanvas.width, 300, 'wireframe', 300, 1.0, 0, 0);
                prevCtx.restore();
            }

            // --- MAUS-INTERAKTION & OBJEKT KLICK ---
            canvas.addEventListener('mousedown', e => {
                const rect = canvas.getBoundingClientRect();
                let tSize = (canvas.width / gridSize) * zoom;
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const gridX = mouseX / tSize + panX;
                const gridY = mouseY / tSize + panY;

                // 1. Wind Kompass Check (Radius 30 um Fix-Pixel 50,50)
                if (Math.hypot(mouseX - 50, mouseY - 50) <= 30) {
                    selectedUI = selectedUI === 'wind' ? null : 'wind';
                    drawMap();
                    return;
                }

                // 2. Pad Check (Grid 8x8)
                if (padX >= 0 && gridX >= padX && gridX <= padX + 8 && gridY >= padY && gridY <= padY + 8) {
                    if (!(currentTool === 'pad' && e.shiftKey)) {
                        selectedUI = selectedUI === 'pad' ? null : 'pad';
                        drawMap();
                        return;
                    }
                }

                // 3. Tr√§ger Check (Radius 6 Grid-Felder um Mitte)
                if (carrierX >= 0 && Math.hypot(gridX - carrierX, gridY - carrierY) <= 6) {
                    if (!(currentTool === 'carrier' && e.shiftKey)) {
                        selectedUI = selectedUI === 'carrier' ? null : 'carrier';
                        drawMap();
                        return;
                    }
                }

                // Klick auf nichts Spezielles: UI verbergen
                selectedUI = null;
                drawMap();

                if (currentTool === 'move') {
                    isEditorDragging = true;
                    lastEditorMouseX = e.clientX;
                    lastEditorMouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                } else {
                    isDrawing = true;
                    paint(e);
                }
            });

            canvas.addEventListener('mousemove', e => {
                if (currentTool === 'move' && isEditorDragging) {
                    let currentTileSize = (canvas.width / gridSize) * zoom;
                    panX -= (e.clientX - lastEditorMouseX) / currentTileSize;
                    panY -= (e.clientY - lastEditorMouseY) / currentTileSize;
                    lastEditorMouseX = e.clientX;
                    lastEditorMouseY = e.clientY;
                    clampCamera();
                    drawMap();
                } else if (isDrawing) {
                    paint(e);
                }
            });

            window.addEventListener('mouseup', () => {
                if (isDrawing) {
                    isDrawing = false;
                    drawPreview();
                }
                if (isEditorDragging) {
                    isEditorDragging = false;
                    if (currentTool === 'move') canvas.style.cursor = 'grab';
                }
                if (isPrevDragging) {
                    isPrevDragging = false;
                }
            });

            function paint(e) {
                const rect = canvas.getBoundingClientRect();
                let tSize = (canvas.width / gridSize) * zoom;
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const gridX = Math.floor(mouseX / tSize + panX);
                const gridY = Math.floor(mouseY / tSize + panY);

                if (currentTool === 'terrain' && gridX >= 0 && gridX <= gridSize && gridY >= 0 && gridY <= gridSize) {
                    let amount = e.shiftKey ? -0.2 : 0.2;
                    let radiusInt = Math.ceil(brushRadius);
                    for (let dx = -radiusInt; dx <= radiusInt; dx++) {
                        for (let dy = -radiusInt; dy <= radiusInt; dy++) {
                            if (Math.hypot(dx, dy) <= brushRadius) {
                                let nx = gridX + dx,
                                    ny = gridY + dy;
                                if (nx >= 0 && nx <= gridSize && ny >= 0 && ny <= gridSize) {
                                    let newH = points[nx][ny] + amount;
                                    if (newH < 0) newH = -1;
                                    if (points[nx][ny] < 0 && amount > 0) newH = 0;
                                    points[nx][ny] = Math.min(15, newH);
                                }
                            }
                        }
                    }
                } else if (
                    currentTool === 'flatten' &&
                    gridX >= 0 &&
                    gridX <= gridSize &&
                    gridY >= 0 &&
                    gridY <= gridSize
                ) {
                    let targetH = e.shiftKey ? -1 : 1.0;
                    let radiusInt = Math.ceil(brushRadius);
                    for (let dx = -radiusInt; dx <= radiusInt; dx++) {
                        for (let dy = -radiusInt; dy <= radiusInt; dy++) {
                            if (Math.hypot(dx, dy) <= brushRadius) {
                                let nx = gridX + dx,
                                    ny = gridY + dy;
                                if (nx >= 0 && nx <= gridSize && ny >= 0 && ny <= gridSize) {
                                    points[nx][ny] = targetH;
                                }
                            }
                        }
                    }
                } else if (currentTool === 'pad') {
                    if (e.shiftKey) {
                        padX = -1;
                        padY = -1;
                        if (selectedUI === 'pad') selectedUI = null;
                        checkSpawnFallback();
                    } else if (gridX >= 0 && gridX <= gridSize - 8 && gridY >= 0 && gridY <= gridSize - 8) {
                        padX = gridX;
                        padY = gridY;
                    }
                } else if (currentTool === 'carrier') {
                    if (e.shiftKey) {
                        carrierX = -1;
                        carrierY = -1;
                        if (selectedUI === 'carrier') selectedUI = null;
                        checkSpawnFallback();
                    } else if (gridX >= 0 && gridX <= gridSize && gridY >= 0 && gridY <= gridSize) {
                        carrierX = gridX;
                        carrierY = gridY;
                    }
                } else if (currentTool === 'lighthouse') {
                    if (e.shiftKey) {
                        lighthouseX = -1;
                        lighthouseY = -1;
                    } else if (gridX >= 0 && gridX <= gridSize && gridY >= 0 && gridY <= gridSize) {
                        lighthouseX = gridX;
                        lighthouseY = gridY;
                    }
                }
                drawMap();
            }

            // --- KOMPRESSION ---
            function compressTerrain(pointsArray) {
                let flat = [];
                for (let x = 0; x <= gridSize; x++) {
                    for (let y = 0; y <= gridSize; y++) flat.push(Math.round(pointsArray[x][y] * 10));
                }
                let compressed = [],
                    count = 1,
                    current = flat[0];
                for (let i = 1; i < flat.length; i++) {
                    if (flat[i] === current) count++;
                    else {
                        compressed.push(count > 1 ? `${current}x${count}` : `${current}`);
                        current = flat[i];
                        count = 1;
                    }
                }
                compressed.push(count > 1 ? `${current}x${count}` : `${current}`);
                return compressed.join(',');
            }

            function decompressTerrain(dataStr, targetGridSize) {
                let flat = [],
                    tokens = dataStr.split(',');
                for (let token of tokens) {
                    if (token.includes('x')) {
                        let parts = token.split('x');
                        let val = parseInt(parts[0]) / 10,
                            count = parseInt(parts[1]);
                        for (let i = 0; i < count; i++) flat.push(val);
                    } else flat.push(parseInt(token) / 10);
                }
                let result = [],
                    i = 0;
                for (let x = 0; x <= targetGridSize; x++) {
                    result[x] = [];
                    for (let y = 0; y <= targetGridSize; y++) result[x][y] = flat[i++];
                }
                return result;
            }

            // --- EXPORT & IMPORT ---
            function exportMap() {
                let expCanvas = document.createElement('canvas');
                expCanvas.width = 400;
                expCanvas.height = 300;
                let eCtx = expCanvas.getContext('2d');
                eCtx.fillStyle = '#050505';
                eCtx.fillRect(0, 0, 400, 300);
                renderIsoMap(eCtx, 400, 300, 'wireframe', 0, 1.0, 0, 0);

                let mapData = {
                    format: 'rle',
                    gridSize: gridSize,
                    headline: document.getElementById('m_headline').value,
                    sublines: document
                        .getElementById('m_sublines')
                        .value.split('\n')
                        .filter(l => l.trim() !== ''),
                    goalPersons: parseInt(document.getElementById('m_persons').value) || 0,
                    goalCrates: parseInt(document.getElementById('m_crates').value) || 0,
                    spawnPoint: spawnPoint,
                    rain: document.getElementById('m_rain').checked,
                    night: document.getElementById('m_night').checked,
                    windStr: parseFloat(document.getElementById('m_wind_str').value) || 0,
                    windDir: parseInt(document.getElementById('m_wind_dir').value) || 0,
                    windVar: document.getElementById('m_wind_var').checked,
                    carrierPath: document.getElementById('m_carrier_path').value,
                    carrierSpeed: parseFloat(document.getElementById('m_carrier_speed').value) || 0,
                    carrierRadius: parseFloat(document.getElementById('m_carrier_radius').value) || 40,
                    padX: padX,
                    padY: padY,
                    carrierX: carrierX,
                    carrierY: carrierY,
                    carrierAngle: carrierAngle,
                    lighthouseX: lighthouseX,
                    lighthouseY: lighthouseY,
                    previewBase64: expCanvas.toDataURL('image/jpeg', 0.6),
                    terrain: compressTerrain(points),
                };
                document.getElementById('output').value = JSON.stringify(mapData);
            }

            function importMap() {
                try {
                    const jsonString = document.getElementById('output').value;
                    if (!jsonString) return alert('Textfeld ist leer!');
                    let imported = JSON.parse(jsonString);

                    if (imported.format === 'rle') {
                        gridSize = imported.gridSize || 100;
                        document.getElementById('m_grid_size').value = gridSize;
                        zoom = 1.0;
                        panX = 0;
                        panY = 0;
                        prevZoom = 1.0;
                        prevPanX = 0;
                        prevPanY = 0;
                        selectedUI = null;

                        padX = imported.padX !== undefined ? imported.padX : 10;
                        padY = imported.padY !== undefined ? imported.padY : 10;
                        carrierX = imported.carrierX !== undefined ? imported.carrierX : -1;
                        carrierY = imported.carrierY !== undefined ? imported.carrierY : -1;
                        carrierAngle = imported.carrierAngle || 0;
                        document.getElementById('m_carrier_angle').value = carrierAngle;

                        lighthouseX = imported.lighthouseX !== undefined ? imported.lighthouseX : -1;
                        lighthouseY = imported.lighthouseY !== undefined ? imported.lighthouseY : -1;

                        spawnPoint = imported.spawnPoint || 'pad';

                        points = decompressTerrain(imported.terrain, gridSize);

                        if (imported.headline) document.getElementById('m_headline').value = imported.headline;
                        if (imported.sublines)
                            document.getElementById('m_sublines').value = imported.sublines.join('\n');
                        document.getElementById('m_persons').value =
                            imported.goalPersons !== undefined ? imported.goalPersons : 5;
                        document.getElementById('m_crates').value =
                            imported.goalCrates !== undefined ? imported.goalCrates : 0;

                        document.getElementById('m_rain').checked = !!imported.rain;
                        document.getElementById('m_night').checked = !!imported.night;
                        document.getElementById('m_wind_str').value =
                            imported.windStr !== undefined ? imported.windStr : 1.0;
                        document.getElementById('m_wind_dir').value =
                            imported.windDir !== undefined ? imported.windDir : 45;
                        document.getElementById('m_wind_var').checked = !!imported.windVar;

                        document.getElementById('m_carrier_path').value = imported.carrierPath || 'static';
                        document.getElementById('m_carrier_speed').value = imported.carrierSpeed || 0;
                        document.getElementById('m_carrier_radius').value = imported.carrierRadius || 40;
                    } else {
                        alert('Bitte verwende das aktuelle Export-Format.');
                        return;
                    }
                    drawMap();
                    drawPreview();
                    alert('Mission erfolgreich geladen!');
                } catch (e) {
                    alert('Fehler beim Importieren!\n\n' + e);
                }
            }

            function clearMap() {
                if (confirm('Wirklich alles l√∂schen?')) initMap();
            }
            initMap();
        </script>
    </body>
</html>
